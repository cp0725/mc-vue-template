{"version":3,"sources":["webpack:///./node_modules/_echarts@4.1.0@echarts/lib/coord/axisModelCreator.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/coord/cartesian/GridModel.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/coord/cartesian/Axis2D.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/coord/cartesian/AxisModel.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/coord/cartesian/Cartesian.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/component/axis/CartesianAxisView.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/coord/axisDefault.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/coord/cartesian/Grid.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/component/axis.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/chart/helper/labelHelper.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/coord/cartesian/Cartesian2D.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/component/gridSimple.js"],"names":["zrUtil","__webpack_require__","axisDefault","ComponentModel","_layout","getLayoutParams","mergeLayoutParam","OrdinalMeta","AXIS_TYPES","_default","axisName","BaseAxisModelClass","axisTypeDefaulter","extraDefaultOption","each","axisType","extend","type","mergeDefaultAndTheme","option","ecModel","layoutMode","this","inputPositionParams","themeModel","getTheme","merge","get","getDefaultOption","optionUpdated","thisOption","__ordinalMeta","createByAxisModel","getCategories","rawData","data","categories","getOrdinalMeta","defaultOption","mergeAll","registerSubTypeDefaulter","curry","module","exports","dependencies","coordinateSystem","show","zlevel","z","left","top","right","bottom","containLabel","backgroundColor","borderWidth","borderColor","Axis","Axis2D","dim","scale","coordExtent","position","call","prototype","constructor","index","getAxesOnZeroOf","model","isHorizontal","getGlobalExtent","asc","ret","getExtent","toGlobalCoord","reverse","getOtherAxis","grid","pointToData","point","clamp","coordToData","toLocalCoord","inherits","axisModelCreator","axisModelCommonMixin","AxisModel","axis","init","superApply","arguments","resetRange","mergeOption","restoreData","getCoordSysModel","queryComponents","mainType","gridIndex","id","gridId","getAxisType","axisDim","extraOption","offset","dimAxisMapper","_axes","Cartesian","name","_dimList","getAxis","getAxes","map","getAxesByScale","scaleType","toLowerCase","filter","addAxis","push","dataToCoord","val","_dataCoordConvert","input","method","dimList","output","Array","i","length","graphic","AxisBuilder","AxisView","cartesianAxisHelper","axisBuilderAttrs","selfBuilderAttrs","CartesianAxisView","axisPointerClass","render","axisModel","api","payload","group","removeAll","oldAxisGroup","_axisGroup","Group","add","gridModel","layout","axisBuilder","getGroup","groupTransition","superCall","remove","_splitAreaColors","_splitLine","isBlank","splitLineModel","getModel","lineStyleModel","lineColors","isArray","gridRect","getRect","lineCount","ticksCoords","getTicksCoords","tickModel","p1","p2","lineStyle","getLineStyle","tickCoord","coord","y","height","x","width","colorIndex","tickValue","Line","subPixelOptimizeLine","anid","shape","x1","y1","x2","y2","style","defaults","stroke","silent","_splitArea","splitAreaModel","areaStyleModel","areaColors","areaColorsLen","lastSplitAreaColors","newSplitAreaColors","createHashMap","cIndex","prev","areaStyle","getAreaStyle","set","Rect","fill","inverse","nameLocation","nameRotate","nameTruncate","maxWidth","ellipsis","placeholder","nameTextStyle","nameGap","triggerEvent","tooltip","axisPointer","axisLine","onZero","onZeroAxisIndex","color","symbol","symbolSize","axisTick","inside","axisLabel","rotate","showMinLabel","showMaxLabel","margin","fontSize","splitLine","splitArea","categoryAxis","boundaryGap","deduplication","alignWithLabel","interval","valueAxis","splitNumber","timeAxis","min","max","logAxis","logBase","_config","_util","__DEV__","isObject","indexOf","retrieve","getLayoutRect","_axisHelper","createScaleByModel","ifAxisCrossZero","niceScaleExtent","estimateLabelUnionRect","Cartesian2D","CoordinateSystem","_dataStackHelper","getStackedDimension","isAxisUsedInTheGrid","Grid","_coordsMap","_coordsList","_axesMap","_axesList","_initCartesian","gridProto","fixAxisOnZero","axesMap","otherAxisDim","otherAxis","otherAxes","idx","hasOwnProperty","canOnZeroToAxis","updateAxisTransform","coordBase","axisExtent","axisExtentSum","axisPointerEnabled","_rect","update","_updateScale","xAxis","yAxis","resize","ignoreContainLabel","getBoxLayoutParams","getWidth","getHeight","axesList","adjustAxes","extent","setExtent","labelUnionRect","axisIndex","axesMapOnDim","slice","getCartesian","xAxisIndex","yAxisIndex","key","coordList","getCartesians","convertToPixel","finder","value","target","_findConvertTarget","cartesian","dataToPoint","convertFromPixel","seriesModel","xAxisModel","getReferringComponents","yAxisModel","coordsList","componentIndex","containPoint","axisPositionUsed","axesCount","eachComponent","createAxisCreator","axisPosition","isCategory","onBand","unionExtent","mapDimension","unionExtentFromData","Infinity","eachSeries","isCartesian2D","axesModels","findAxesModels","getData","getTooltipAxes","baseAxes","baseAxis","getBaseAxis","axesTypes","create","grids","dimensions","register","_dataProvider","retrieveRawValue","getDefaultLabel","dataIndex","labelDims","len","vals","join","axisX","axisY","contain","containData","reserved","out","clampData","xScale","yScale","xAxisExtent","yAxisExtent","parse","Math","echarts","extendComponentView","getItemStyle","z2","registerPreprocessor"],"mappings":"qGAAA,IAAAA,EAAaC,EAAQ,QAErBC,EAAkBD,EAAQ,QAE1BE,EAAqBF,EAAQ,QAE7BG,EAAcH,EAAQ,QAEtBI,EAAAD,EAAAC,gBACAC,EAAAF,EAAAE,iBAEAC,EAAkBN,EAAQ,QAqB1BO,GAAA,iCASA,SAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACAb,EAAAc,KAAAN,EAAA,SAAAO,GACAJ,EAAAK,QAIAC,KAAAP,EAAA,QAAAK,EACAG,qBAAA,SAAAC,EAAAC,GACA,IAAAC,EAAAC,KAAAD,WACAE,EAAAF,EAAAhB,EAAAc,MACAK,EAAAJ,EAAAK,WACAzB,EAAA0B,MAAAP,EAAAK,EAAAG,IAAAZ,EAAA,SACAf,EAAA0B,MAAAP,EAAAG,KAAAM,oBACAT,EAAAF,KAAAL,EAAAF,EAAAS,GAEAE,GACAf,EAAAa,EAAAI,EAAAF,IAOAQ,cAAA,WACA,IAAAC,EAAAR,KAAAH,OAEA,aAAAW,EAAAb,OACAK,KAAAS,cAAAxB,EAAAyB,kBAAAV,QAQAW,cAAA,SAAAC,GACA,IAAAf,EAAAG,KAAAH,OAGA,gBAAAA,EAAAF,KACA,OAAAiB,EACAf,EAAAgB,KAGAb,KAAAS,cAAAK,YAGAC,eAAA,WACA,OAAAf,KAAAS,eAEAO,cAAAtC,EAAAuC,aAAwCrC,EAAAa,EAAA,QAAAF,IAAA,OAGxCV,EAAAqC,yBAAA9B,EAAA,OAAAV,EAAAyC,MAAA7B,EAAAF,IAGAgC,EAAAC,QAAAlC,0BCjGAR,EAAQ,QAER,IAAAE,EAAqBF,EAAQ,QAsB7BQ,EAAAN,EAAAa,QACAC,KAAA,OACA2B,cAAA,iBACAvB,WAAA,MAKAwB,iBAAA,KACAP,eACAQ,MAAA,EACAC,OAAA,EACAC,EAAA,EACAC,KAAA,MACAC,IAAA,GACAC,MAAA,MACAC,OAAA,GAEAC,cAAA,EAGAC,gBAAA,gBACAC,YAAA,EACAC,YAAA,UAIAd,EAAAC,QAAAlC,wBCnDA,IAAAT,EAAaC,EAAQ,QAErBwD,EAAWxD,EAAQ,QA+BnByD,EAAA,SAAAC,EAAAC,EAAAC,EAAA9C,EAAA+C,GACAL,EAAAM,KAAAzC,KAAAqC,EAAAC,EAAAC,GAUAvC,KAAAL,KAAAF,GAAA,QASAO,KAAAwC,YAAA,UAGAJ,EAAAM,WACAC,YAAAP,EAKAQ,MAAA,EAQAC,gBAAA,KAMAC,MAAA,KACAC,aAAA,WACA,IAAAP,EAAAxC,KAAAwC,SACA,cAAAA,GAAA,WAAAA,GAWAQ,gBAAA,SAAAC,GACA,IAAAC,EAAAlD,KAAAmD,YAIA,OAHAD,EAAA,GAAAlD,KAAAoD,cAAAF,EAAA,IACAA,EAAA,GAAAlD,KAAAoD,cAAAF,EAAA,IACAD,GAAAC,EAAA,GAAAA,EAAA,IAAAA,EAAAG,UACAH,GAEAI,aAAA,WACAtD,KAAAuD,KAAAD,gBAMAE,YAAA,SAAAC,EAAAC,GACA,OAAA1D,KAAA2D,YAAA3D,KAAA4D,aAAAH,EAAA,MAAAzD,KAAAqC,IAAA,MAAAqB,IASAE,aAAA,KAQAR,cAAA,MAEA1E,EAAAmF,SAAAzB,EAAAD,GACA,IAAAhD,EAAAiD,EACAhB,EAAAC,QAAAlC,0BC9HA,IAAAT,EAAaC,EAAQ,QAErBE,EAAqBF,EAAQ,QAE7BmF,EAAuBnF,EAAQ,QAE/BoF,EAA2BpF,EAAQ,QAoBnCqF,EAAAnF,EAAAa,QACAC,KAAA,kBAKAsE,KAAA,KAKAC,KAAA,WACAF,EAAAG,WAAAnE,KAAA,OAAAoE,WACApE,KAAAqE,cAMAC,YAAA,WACAN,EAAAG,WAAAnE,KAAA,cAAAoE,WACApE,KAAAqE,cAMAE,YAAA,WACAP,EAAAG,WAAAnE,KAAA,cAAAoE,WACApE,KAAAqE,cAOAG,iBAAA,WACA,OAAAxE,KAAAF,QAAA2E,iBACAC,SAAA,OACA9B,MAAA5C,KAAAH,OAAA8E,UACAC,GAAA5E,KAAAH,OAAAgF,SACK,MAIL,SAAAC,EAAAC,EAAAlF,GAEA,OAAAA,EAAAF,OAAAE,EAAAgB,KAAA,oBAGAnC,EAAA0B,MAAA4D,EAAAtB,UAAAqB,GACA,IAAAiB,GAIAC,OAAA,GAEAnB,EAAA,IAAAE,EAAAc,EAAAE,GACAlB,EAAA,IAAAE,EAAAc,EAAAE,GACA,IAAA7F,EAAA6E,EACA5C,EAAAC,QAAAlC,wBCtFA,IAAAT,EAAaC,EAAQ,QA0BrB,SAAAuG,EAAA7C,GACA,OAAArC,KAAAmF,MAAA9C,GAQA,IAAA+C,EAAA,SAAAC,GACArF,KAAAmF,SACAnF,KAAAsF,YAKAtF,KAAAqF,QAAA,IAGAD,EAAA1C,WACAC,YAAAyC,EACAzF,KAAA,YAOA4F,QAAA,SAAAlD,GACA,OAAArC,KAAAmF,MAAA9C,IAOAmD,QAAA,WACA,OAAA9G,EAAA+G,IAAAzF,KAAAsF,SAAAJ,EAAAlF,OAMA0F,eAAA,SAAAC,GAEA,OADAA,IAAAC,cACAlH,EAAAmH,OAAA7F,KAAAwF,UAAA,SAAAvB,GACA,OAAAA,EAAA3B,MAAA3C,OAAAgG,KAQAG,QAAA,SAAA7B,GACA,IAAA5B,EAAA4B,EAAA5B,IACArC,KAAAmF,MAAA9C,GAAA4B,EAEAjE,KAAAsF,SAAAS,KAAA1D,IAQA2D,YAAA,SAAAC,GACA,OAAAjG,KAAAkG,kBAAAD,EAAA,gBAQAtC,YAAA,SAAAsC,GACA,OAAAjG,KAAAkG,kBAAAD,EAAA,gBAEAC,kBAAA,SAAAC,EAAAC,GAIA,IAHA,IAAAC,EAAArG,KAAAsF,SACAgB,EAAAH,aAAAI,YAEAC,EAAA,EAAmBA,EAAAH,EAAAI,OAAoBD,IAAA,CACvC,IAAAnE,EAAAgE,EAAAG,GACAvC,EAAAjE,KAAAmF,MAAA9C,GACAiE,EAAAjE,GAAA4B,EAAAmC,GAAAD,EAAA9D,IAGA,OAAAiE,IAGA,IAAAnH,EAAAiG,EACAhE,EAAAC,QAAAlC,0BCtHA,IAAAT,EAAaC,EAAQ,QAErB+H,EAAc/H,EAAQ,QAEtBgI,EAAkBhI,EAAQ,QAE1BiI,EAAejI,EAAQ,QAEvBkI,EAA0BlI,EAAQ,QAoBlCmI,GAAA,uCACAC,GAAA,yBAQAC,EAAAJ,EAAAlH,QACAC,KAAA,gBACAsH,iBAAA,uBAKAC,OAAA,SAAAC,EAAArH,EAAAsH,EAAAC,GACArH,KAAAsH,MAAAC,YACA,IAAAC,EAAAxH,KAAAyH,WAIA,GAHAzH,KAAAyH,WAAA,IAAAf,EAAAgB,MACA1H,KAAAsH,MAAAK,IAAA3H,KAAAyH,YAEAN,EAAA9G,IAAA,SAIA,IAAAuH,EAAAT,EAAA3C,mBACAqD,EAAAhB,EAAAgB,OAAAD,EAAAT,GACAW,EAAA,IAAAnB,EAAAQ,EAAAU,GACAnJ,EAAAc,KAAAsH,EAAAgB,EAAAH,IAAAG,GAEA9H,KAAAyH,WAAAE,IAAAG,EAAAC,YAEArJ,EAAAc,KAAAuH,EAAA,SAAA1B,GACA8B,EAAA9G,IAAAgF,EAAA,UACArF,KAAA,IAAAqF,GAAA8B,EAAAS,IAEK5H,MACL0G,EAAAsB,gBAAAR,EAAAxH,KAAAyH,WAAAN,GACAH,EAAAiB,UAAAjI,KAAA,SAAAmH,EAAArH,EAAAsH,EAAAC,KAEAa,OAAA,WACAlI,KAAAmI,iBAAA,MAQAC,WAAA,SAAAjB,EAAAS,GACA,IAAA3D,EAAAkD,EAAAlD,KAEA,IAAAA,EAAA3B,MAAA+F,UAAA,CAIA,IAAAC,EAAAnB,EAAAoB,SAAA,aACAC,EAAAF,EAAAC,SAAA,aACAE,EAAAD,EAAAnI,IAAA,SACAoI,EAAA/J,EAAAgK,QAAAD,SAaA,IAZA,IAAAE,EAAAf,EAAArG,iBAAAqH,UACA7F,EAAAkB,EAAAlB,eACA8F,EAAA,EACAC,EAAA7E,EAAA8E,gBACAC,UAAAV,IAEAW,KACAC,KAGAC,EAAAX,EAAAY,eAEA5C,EAAA,EAAmBA,EAAAsC,EAAArC,OAAwBD,IAAA,CAC3C,IAAA6C,EAAApF,EAAAb,cAAA0F,EAAAtC,GAAA8C,OAEAvG,GACAkG,EAAA,GAAAI,EACAJ,EAAA,GAAAN,EAAAY,EACAL,EAAA,GAAAG,EACAH,EAAA,GAAAP,EAAAY,EAAAZ,EAAAa,SAEAP,EAAA,GAAAN,EAAAc,EACAR,EAAA,GAAAI,EACAH,EAAA,GAAAP,EAAAc,EAAAd,EAAAe,MACAR,EAAA,GAAAG,GAGA,IAAAM,EAAAd,IAAAJ,EAAAhC,OACAmD,EAAAd,EAAAtC,GAAAoD,UAEA5J,KAAAyH,WAAAE,IAAA,IAAAjB,EAAAmD,KAAAnD,EAAAoD,sBACAC,KAAA,MAAAH,EAAA,QAAAd,EAAAtC,GAAAoD,UAAA,KACAI,OACAC,GAAAhB,EAAA,GACAiB,GAAAjB,EAAA,GACAkB,GAAAjB,EAAA,GACAkB,GAAAlB,EAAA,IAEAmB,MAAA3L,EAAA4L,UACAC,OAAA9B,EAAAkB,IACSR,GACTqB,QAAA,SAUAC,WAAA,SAAAtD,EAAAS,GACA,IAAA3D,EAAAkD,EAAAlD,KAEA,IAAAA,EAAA3B,MAAA+F,UAAA,CAIA,IAAAqC,EAAAvD,EAAAoB,SAAA,aACAoC,EAAAD,EAAAnC,SAAA,aACAqC,EAAAD,EAAAtK,IAAA,SACAsI,EAAAf,EAAArG,iBAAAqH,UACAE,EAAA7E,EAAA8E,gBACAC,UAAA0B,EACAhH,OAAA,IAGA,GAAAoF,EAAArC,OAAA,CAMA,IAAAoE,EAAAD,EAAAnE,OACAqE,EAAA9K,KAAAmI,iBACA4C,EAAArM,EAAAsM,gBACArB,EAAA,EAEA,GAAAmB,EACA,QAAAtE,EAAA,EAAqBA,EAAAsC,EAAArC,OAAwBD,IAAA,CAC7C,IAAAyE,EAAAH,EAAAzK,IAAAyI,EAAAtC,GAAAoD,WAEA,SAAAqB,EAAA,CACAtB,GAAAsB,GAAAJ,EAAA,GAAArE,GAAAqE,EACA,OAKA,IAAAK,EAAAjH,EAAAb,cAAA0F,EAAA,GAAAQ,OACA6B,EAAAR,EAAAS,eACAR,EAAAlM,EAAAgK,QAAAkC,SAEA,IAAApE,EAAA,EAAmBA,EAAAsC,EAAArC,OAAwBD,IAAA,CAC3C,IACAiD,EACAF,EACAG,EACAF,EAJAH,EAAApF,EAAAb,cAAA0F,EAAAtC,GAAA8C,OAMArF,EAAAlB,gBACA0G,EAAAyB,EACA3B,EAAAZ,EAAAY,EACAG,EAAAL,EAAAI,EACAD,EAAAb,EAAAa,OACA0B,EAAAzB,EAAAC,IAEAD,EAAAd,EAAAc,EACAF,EAAA2B,EACAxB,EAAAf,EAAAe,MACAF,EAAAH,EAAAE,EACA2B,EAAA3B,EAAAC,GAGA,IAAAI,EAAAd,EAAAtC,EAAA,GAAAoD,UACA,MAAAA,GAAAmB,EAAAM,IAAAzB,EAAAD,GAEA3J,KAAAyH,WAAAE,IAAA,IAAAjB,EAAA4E,MACAvB,KAAA,MAAAH,EAAA,QAAAA,EAAA,KACAI,OACAP,IACAF,IACAG,QACAF,UAEAa,MAAA3L,EAAA4L,UACAiB,KAAAX,EAAAjB,IACSwB,GACTX,QAAA,KAGAb,KAAA,GAAAkB,EAGA7K,KAAAmI,iBAAA4C,OAGA/D,EAAAtH,QACAC,KAAA,UAEAqH,EAAAtH,QACAC,KAAA,kCCtOA,IAAAjB,EAAaC,EAAQ,QAoBrBqC,GACAQ,MAAA,EACAC,OAAA,EACAC,EAAA,EAEA8J,SAAA,EAEAnG,KAAA,GAEAoG,aAAA,MAEAC,WAAA,KACAC,cACAC,SAAA,KACAC,SAAA,MACAC,YAAA,KAGAC,iBAEAC,QAAA,GAEAxB,QAAA,EAEAyB,cAAA,EACAC,SACA1K,MAAA,GAEA2K,eACAC,UACA5K,MAAA,EACA6K,QAAA,EACAC,gBAAA,KACAnD,WACAoD,MAAA,OACA7C,MAAA,EACA/J,KAAA,SAGA6M,QAAA,eACAC,YAAA,QAEAC,UACAlL,MAAA,EAEAmL,QAAA,EAEAlG,OAAA,EACA0C,WACAO,MAAA,IAGAkD,WACApL,MAAA,EAEAmL,QAAA,EACAE,OAAA,EAEAC,aAAA,KAEAC,aAAA,KACAC,OAAA,EAEAC,SAAA,IAEAC,WACA1L,MAAA,EACA2H,WACAoD,OAAA,QACA7C,MAAA,EACA/J,KAAA,UAGAwN,WACA3L,MAAA,EACA2J,WACAoB,OAAA,oDAIA3N,KACAA,EAAAwO,aAAA1O,EAAA0B,OAEAiN,aAAA,EAQAC,cAAA,KAIAJ,WACA1L,MAAA,GAEAkL,UAEAa,gBAAA,EACAC,SAAA,QAEAZ,WACAY,SAAA,SAECxM,GACDpC,EAAA6O,UAAA/O,EAAA0B,OAGAiN,aAAA,KAsBAK,YAAA,GAOC1M,GACDpC,EAAA+O,SAAAjP,EAAA4L,UACAhI,OAAA,EACAsL,IAAA,UACAC,IAAA,WACCjP,EAAA6O,WACD7O,EAAAkP,QAAApP,EAAA4L,UACAhI,OAAA,EACAyL,QAAA,IACCnP,EAAA6O,WACD,IAAAtO,EAAAP,EACAwC,EAAAC,QAAAlC,0BC1KA,IAAA6O,EAAcrP,EAAQ,QAItBsP,GAFAD,EAAAE,QAEYvP,EAAQ,SAEpBwP,EAAAF,EAAAE,SACA3O,EAAAyO,EAAAzO,KACAiG,EAAAwI,EAAAxI,IACA2I,EAAAH,EAAAG,QAGAtP,GAFAmP,EAAAI,SAEc1P,EAAQ,SAEtB2P,EAAAxP,EAAAwP,cAEAC,EAAkB5P,EAAQ,QAE1B6P,EAAAD,EAAAC,mBACAC,EAAAF,EAAAE,gBACAC,EAAAH,EAAAG,gBACAC,EAAAJ,EAAAI,uBAEAC,EAAkBjQ,EAAQ,QAE1ByD,EAAazD,EAAQ,QAErBkQ,EAAuBlQ,EAAQ,QAE/BmQ,EAAuBnQ,EAAQ,QAE/BoQ,EAAAD,EAAAC,oBAkCA,SAAAC,EAAA7H,EAAAS,EAAA9H,GACA,OAAAqH,EAAA3C,qBAAAoD,EAGA,SAAAqH,EAAArH,EAAA9H,EAAAsH,GAKApH,KAAAkP,cAMAlP,KAAAmP,eAMAnP,KAAAoP,YAMApP,KAAAqP,aAEArP,KAAAsP,eAAA1H,EAAA9H,EAAAsH,GAEApH,KAAA8C,MAAA8E,EA/DAjJ,EAAQ,QAkER,IAAA4Q,EAAAN,EAAAvM,UA8BA,SAAA8M,EAAAC,EAAAC,EAAAzL,GACAA,EAAApB,gBAAA,WAEA,OAAA8M,UAMA,IACAA,EADAC,EAAAH,EAAAC,GAEAvI,EAAAlD,EAAAnB,MACAuJ,EAAAlF,EAAA9G,IAAA,mBACAiM,EAAAnF,EAAA9G,IAAA,4BAEA,GAAAgM,EAKA,SAAAC,GASA,QAAAuD,KAAAD,EACA,GAAAA,EAAAE,eAAAD,IAAAE,EAAAH,EAAAC,IAAA,CACAF,EAAAC,EAAAC,GACA,YAXAE,EAAAH,EAAAtD,MACAqD,EAAAC,EAAAtD,IAeA,SAAAyD,EAAA9L,GACA,OAAAA,GAAA,aAAAA,EAAAtE,MAAA,SAAAsE,EAAAtE,MAAA8O,EAAAxK,GAiWA,SAAA+L,EAAA/L,EAAAgM,GACA,IAAAC,EAAAjM,EAAAd,YACAgN,EAAAD,EAAA,GAAAA,EAAA,GAEAjM,EAAAb,cAAA,MAAAa,EAAA5B,IAAA,SAAAiH,GACA,OAAAA,EAAA2G,GACG,SAAA3G,GACH,OAAA6G,EAAA7G,EAAA2G,GAEAhM,EAAAL,aAAA,MAAAK,EAAA5B,IAAA,SAAAiH,GACA,OAAAA,EAAA2G,GACG,SAAA3G,GACH,OAAA6G,EAAA7G,EAAA2G,GAhbAV,EAAA5P,KAAA,OACA4P,EAAAa,oBAAA,EAEAb,EAAA3G,QAAA,WACA,OAAA5I,KAAAqQ,OAGAd,EAAAe,OAAA,SAAAxQ,EAAAsH,GACA,IAAAqI,EAAAzP,KAAAoP,SAEApP,KAAAuQ,aAAAzQ,EAAAE,KAAA8C,OAEAtD,EAAAiQ,EAAAhG,EAAA,SAAA+G,GACA9B,EAAA8B,EAAAlO,MAAAkO,EAAA1N,SAEAtD,EAAAiQ,EAAAlG,EAAA,SAAAkH,GACA/B,EAAA+B,EAAAnO,MAAAmO,EAAA3N,SAEAtD,EAAAiQ,EAAAhG,EAAA,SAAA+G,GACAhB,EAAAC,EAAA,IAAAe,KAEAhR,EAAAiQ,EAAAlG,EAAA,SAAAkH,GACAjB,EAAAC,EAAA,IAAAgB,KAIAzQ,KAAA0Q,OAAA1Q,KAAA8C,MAAAsE,IAkDAmI,EAAAmB,OAAA,SAAA9I,EAAAR,EAAAuJ,GACA,IAAAhI,EAAA2F,EAAA1G,EAAAgJ,sBACAlH,MAAAtC,EAAAyJ,WACArH,OAAApC,EAAA0J,cAEA9Q,KAAAqQ,MAAA1H,EACA,IAAAoI,EAAA/Q,KAAAqP,UAwBA,SAAA2B,IACAxR,EAAAuR,EAAA,SAAA9M,GACA,IAAAlB,EAAAkB,EAAAlB,eACAkO,EAAAlO,GAAA,EAAA4F,EAAAe,QAAA,EAAAf,EAAAa,QACAqG,EAAA5L,EAAAuH,QAAA,IACAvH,EAAAiN,UAAAD,EAAApB,GAAAoB,EAAA,EAAApB,IACAG,EAAA/L,EAAAlB,EAAA4F,EAAAc,EAAAd,EAAAY,KA7BAyH,KAEAL,GAAA/I,EAAAvH,IAAA,kBACAb,EAAAuR,EAAA,SAAA9M,GACA,IAAAA,EAAAnB,MAAAzC,IAAA,qBACA,IAAA8Q,EAAAxC,EAAA1K,GAEA,GAAAkN,EAAA,CACA,IAAA9O,EAAA4B,EAAAlB,eAAA,iBACAiK,EAAA/I,EAAAnB,MAAAzC,IAAA,oBACAsI,EAAAtG,IAAA8O,EAAA9O,GAAA2K,EAEA,QAAA/I,EAAAzB,SACAmG,EAAAY,GAAA4H,EAAA3H,OAAAwD,EACW,SAAA/I,EAAAzB,WACXmG,EAAAc,GAAA0H,EAAAzH,MAAAsD,OAKAgE,MAmBAzB,EAAAhK,QAAA,SAAA9F,EAAA2R,GACA,IAAAC,EAAArR,KAAAoP,SAAA3P,GAEA,SAAA4R,EAAA,CACA,SAAAD,EAEA,QAAA/L,KAAAgM,EACA,GAAAA,EAAAvB,eAAAzK,GACA,OAAAgM,EAAAhM,GAKA,OAAAgM,EAAAD,KAQA7B,EAAA/J,QAAA,WACA,OAAAxF,KAAAqP,UAAAiC,SAcA/B,EAAAgC,aAAA,SAAAC,EAAAC,GACA,SAAAD,GAAA,MAAAC,EAAA,CACA,IAAAC,EAAA,IAAAF,EAAA,IAAAC,EACA,OAAAzR,KAAAkP,WAAAwC,GAGAvD,EAAAqD,KACAC,EAAAD,EAAAC,WACAD,gBAIA,QAAAhL,EAAA,EAAAmL,EAAA3R,KAAAmP,YAA+C3I,EAAAmL,EAAAlL,OAAsBD,IACrE,GAAAmL,EAAAnL,GAAAjB,QAAA,KAAA3C,QAAA4O,GAAAG,EAAAnL,GAAAjB,QAAA,KAAA3C,QAAA6O,EACA,OAAAE,EAAAnL,IAKA+I,EAAAqC,cAAA,WACA,OAAA5R,KAAAmP,YAAAmC,SAQA/B,EAAAsC,eAAA,SAAA/R,EAAAgS,EAAAC,GACA,IAAAC,EAAAhS,KAAAiS,mBAAAnS,EAAAgS,GAEA,OAAAE,EAAAE,UAAAF,EAAAE,UAAAC,YAAAJ,GAAAC,EAAA/N,KAAA+N,EAAA/N,KAAAb,cAAA4O,EAAA/N,KAAA+B,YAAA+L,IAAA,MAQAxC,EAAA6C,iBAAA,SAAAtS,EAAAgS,EAAAC,GACA,IAAAC,EAAAhS,KAAAiS,mBAAAnS,EAAAgS,GAEA,OAAAE,EAAAE,UAAAF,EAAAE,UAAA1O,YAAAuO,GAAAC,EAAA/N,KAAA+N,EAAA/N,KAAAN,YAAAqO,EAAA/N,KAAAL,aAAAmO,IAAA,MAOAxC,EAAA0C,mBAAA,SAAAnS,EAAAgS,GACA,IAKAI,EACAjO,EANAoO,EAAAP,EAAAO,YACAC,EAAAR,EAAAQ,YAAAD,KAAAE,uBAAA,YACAC,EAAAV,EAAAU,YAAAH,KAAAE,uBAAA,YACA3K,EAAAkK,EAAAlK,UACA6K,EAAAzS,KAAAmP,YAIA,GAAAkD,EACAH,EAAAG,EAAA9Q,iBACA6M,EAAAqE,EAAAP,GAAA,IAAAA,EAAA,WACG,GAAAI,GAAAE,EACHN,EAAAlS,KAAAuR,aAAAe,EAAAI,eAAAF,EAAAE,qBACG,GAAAJ,EACHrO,EAAAjE,KAAAuF,QAAA,IAAA+M,EAAAI,qBACG,GAAAF,EACHvO,EAAAjE,KAAAuF,QAAA,IAAAiN,EAAAE,qBAEA,GAAA9K,EAAA,CACA,IAAArE,EAAAqE,EAAArG,iBAEAgC,IAAAvD,OACAkS,EAAAlS,KAAAmP,YAAA,IAIA,OACA+C,YACAjO,SASAsL,EAAAoD,aAAA,SAAAlP,GACA,IAAA6F,EAAAtJ,KAAAmP,YAAA,GAEA,GAAA7F,EACA,OAAAA,EAAAqJ,aAAAlP,IASA8L,EAAAD,eAAA,SAAA1H,EAAA9H,EAAAsH,GACA,IAAAwL,GACAjR,MAAA,EACAE,OAAA,EACAD,KAAA,EACAE,QAAA,GAEA2N,GACAhG,KACAF,MAEAsJ,GACApJ,EAAA,EACAF,EAAA,GAMA,GAHAzJ,EAAAgT,cAAA,QAAAC,EAAA,KAAA/S,MACAF,EAAAgT,cAAA,QAAAC,EAAA,KAAA/S,OAEA6S,EAAApJ,IAAAoJ,EAAAtJ,EAIA,OAFAvJ,KAAAoP,iBACApP,KAAAqP,cAqBA,SAAA0D,EAAAtT,GACA,gBAAA0H,EAAA0I,GACA,GAAAb,EAAA7H,EAAAS,EAAA9H,GAAA,CAIA,IAAAkT,EAAA7L,EAAA9G,IAAA,YAEA,MAAAZ,EAEA,QAAAuT,GAAA,WAAAA,IAEAA,EAAA,SAEAJ,EAAAI,KACAA,EAAA,QAAAA,EAAA,iBAKA,SAAAA,GAAA,UAAAA,IAEAA,EAAA,OAEAJ,EAAAI,KACAA,EAAA,SAAAA,EAAA,iBAKAJ,EAAAI,IAAA,EACA,IAAA/O,EAAA,IAAA7B,EAAA3C,EAAA+O,EAAArH,IAAA,KAAAA,EAAA9G,IAAA,QAAA2S,GACAC,EAAA,aAAAhP,EAAAtE,KACAsE,EAAAiP,OAAAD,GAAA9L,EAAA9G,IAAA,eACA4D,EAAAuH,QAAArE,EAAA9G,IAAA,WAEA8G,EAAAlD,OAEAA,EAAAnB,MAAAqE,EAEAlD,EAAAV,KAAAvD,KAEAiE,EAAArB,MAAAiN,EAEA7P,KAAAqP,UAAAtJ,KAAA9B,GAEAwL,EAAAhQ,GAAAoQ,GAAA5L,EACA4O,EAAApT,OAhEAO,KAAAoP,SAAAK,EAEAjQ,EAAAiQ,EAAAhG,EAAA,SAAA+G,EAAAgB,GACAhS,EAAAiQ,EAAAlG,EAAA,SAAAkH,EAAAgB,GACA,IAAAC,EAAA,IAAAF,EAAA,IAAAC,EACAS,EAAA,IAAAtD,EAAA8C,GACAQ,EAAA3O,KAAAvD,KACAkS,EAAApP,MAAA8E,EACA5H,KAAAkP,WAAAwC,GAAAQ,EAEAlS,KAAAmP,YAAApJ,KAAAmM,GAEAA,EAAApM,QAAA0K,GACA0B,EAAApM,QAAA2K,IACKzQ,OACFA,OA4DHuP,EAAAgB,aAAA,SAAAzQ,EAAA8H,GA2BA,SAAAuL,EAAAtS,EAAAoD,EAAAoO,GACA7S,EAAAqB,EAAAuS,aAAAnP,EAAA5B,KAAA,YAAAA,GACA4B,EAAA3B,MAAA+Q,oBAGAxS,EAAAkO,EAAAlO,EAAAwB,MA9BA7C,EAAAQ,KAAAqP,UAAA,SAAApL,GACAA,EAAA3B,MAAA4O,UAAAoC,YAEAxT,EAAAyT,WAAA,SAAAlB,GACA,GAAAmB,EAAAnB,GAAA,CACA,IAAAoB,EAAAC,EAAArB,EAAAvS,GACAwS,EAAAmB,EAAA,GACAjB,EAAAiB,EAAA,GAEA,IAAAzE,EAAAsD,EAAA1K,EAAA9H,KAAAkP,EAAAwD,EAAA5K,EAAA9H,GACA,OAGA,IAAAoS,EAAAlS,KAAAuR,aAAAe,EAAAI,eAAAF,EAAAE,gBACA7R,EAAAwR,EAAAsB,UACAnD,EAAA0B,EAAA3M,QAAA,KACAkL,EAAAyB,EAAA3M,QAAA,KAEA,SAAA1E,EAAAlB,OACAwT,EAAAtS,EAAA2P,EAAA6B,GACAc,EAAAtS,EAAA4P,EAAA4B,MAGGrS,OAiBHuP,EAAAqE,eAAA,SAAAvR,GACA,IAAAwR,KACAjE,KAOA,OANApQ,EAAAQ,KAAA4R,gBAAA,SAAAM,GACA,IAAA4B,EAAA,MAAAzR,GAAA,SAAAA,EAAA6P,EAAA3M,QAAAlD,GAAA6P,EAAA6B,cACApE,EAAAuC,EAAA5O,aAAAwQ,GACA1F,EAAAyF,EAAAC,GAAA,GAAAD,EAAA9N,KAAA+N,GACA1F,EAAAwB,EAAAD,GAAA,GAAAC,EAAA7J,KAAA4J,MAGAkE,WACAjE,cAwBA,IAAAoE,GAAA,iBAKA,SAAAN,EAAArB,EAAAvS,GACA,OAAA2F,EAAAuO,EAAA,SAAAvU,GACA,IAAA0H,EAAAkL,EAAAE,uBAAA9S,GAAA,GACA,OAAA0H,IAQA,SAAAqM,EAAAnB,GACA,sBAAAA,EAAAhS,IAAA,oBAGA4O,EAAAgF,OAAA,SAAAnU,EAAAsH,GACA,IAAA8M,KAuBA,OAtBApU,EAAAgT,cAAA,gBAAAlL,EAAAiI,GACA,IAAAtM,EAAA,IAAA0L,EAAArH,EAAA9H,EAAAsH,GACA7D,EAAA8B,KAAA,QAAAwK,EAGAtM,EAAAmN,OAAA9I,EAAAR,GAAA,GACAQ,EAAArG,iBAAAgC,EACA2Q,EAAAnO,KAAAxC,KAGAzD,EAAAyT,WAAA,SAAAlB,GACA,GAAAmB,EAAAnB,GAAA,CAIA,IAAAoB,EAAAC,EAAArB,EAAAvS,GACAwS,EAAAmB,EAAA,GACAjB,EAAAiB,EAAA,GACA7L,EAAA0K,EAAA9N,mBACAjB,EAAAqE,EAAArG,iBACA8Q,EAAA9Q,iBAAAgC,EAAAgO,aAAAe,EAAAI,eAAAF,EAAAE,mBAEAwB,GAIAjF,EAAAkF,WAAAlF,EAAAvM,UAAAyR,WAAAvF,EAAAlM,UAAAyR,WACAtF,EAAAuF,SAAA,cAAAnF,GACA,IAAA9P,EAAA8P,EACA7N,EAAAC,QAAAlC,wBC3kBAR,EAAQ,QAERA,EAAQ,8BCFR,IAAA0V,EAAoB1V,EAAQ,QAE5B2V,EAAAD,EAAAC,iBA0BA,SAAAC,EAAA1T,EAAA2T,GACA,IAAAC,EAAA5T,EAAAuS,aAAA,qBACAsB,EAAAD,EAAAhO,OAEA,OAAAiO,EACA,OAAAJ,EAAAzT,EAAA2T,EAAAC,EAAA,IACG,GAAAC,EAAA,CAGH,IAFA,IAAAC,KAEAnO,EAAA,EAAmBA,EAAAiO,EAAAhO,OAAsBD,IAAA,CACzC,IAAAP,EAAAqO,EAAAzT,EAAA2T,EAAAC,EAAAjO,IACAmO,EAAA5O,KAAAE,GAGA,OAAA0O,EAAAC,KAAA,MAIAvT,EAAAkT,wCC9CA,IAAA7V,EAAaC,EAAQ,QAErByG,EAAgBzG,EAAQ,QAoBxB,SAAAiQ,EAAAvJ,GACAD,EAAA3C,KAAAzC,KAAAqF,GAGAuJ,EAAAlM,WACAC,YAAAiM,EACAjP,KAAA,cAMAwU,YAAA,SAOAJ,YAAA,WACA,OAAA/T,KAAA0F,eAAA,eAAA1F,KAAA0F,eAAA,YAAA1F,KAAAuF,QAAA,MAQAoN,aAAA,SAAAlP,GACA,IAAAoR,EAAA7U,KAAAuF,QAAA,KACAuP,EAAA9U,KAAAuF,QAAA,KACA,OAAAsP,EAAAE,QAAAF,EAAAjR,aAAAH,EAAA,MAAAqR,EAAAC,QAAAD,EAAAlR,aAAAH,EAAA,MAQAuR,YAAA,SAAAnU,GACA,OAAAb,KAAAuF,QAAA,KAAAyP,YAAAnU,EAAA,KAAAb,KAAAuF,QAAA,KAAAyP,YAAAnU,EAAA,KAQAsR,YAAA,SAAAtR,EAAAoU,EAAAC,GACA,IAAA1E,EAAAxQ,KAAAuF,QAAA,KACAkL,EAAAzQ,KAAAuF,QAAA,KAIA,OAHA2P,QACAA,EAAA,GAAA1E,EAAApN,cAAAoN,EAAAxK,YAAAnF,EAAA,KACAqU,EAAA,GAAAzE,EAAArN,cAAAqN,EAAAzK,YAAAnF,EAAA,KACAqU,GAQAC,UAAA,SAAAtU,EAAAqU,GACA,IAAAE,EAAApV,KAAAuF,QAAA,KAAAjD,MACA+S,EAAArV,KAAAuF,QAAA,KAAAjD,MACAgT,EAAAF,EAAAjS,YACAoS,EAAAF,EAAAlS,YACAsG,EAAA2L,EAAAI,MAAA3U,EAAA,IACA0I,EAAA8L,EAAAG,MAAA3U,EAAA,IAIA,OAHAqU,QACAA,EAAA,GAAAO,KAAA7H,IAAA6H,KAAA5H,IAAA4H,KAAA7H,IAAA0H,EAAA,GAAAA,EAAA,IAAA7L,GAAAgM,KAAA5H,IAAAyH,EAAA,GAAAA,EAAA,KACAJ,EAAA,GAAAO,KAAA7H,IAAA6H,KAAA5H,IAAA4H,KAAA7H,IAAA2H,EAAA,GAAAA,EAAA,IAAAhM,GAAAkM,KAAA5H,IAAA0H,EAAA,GAAAA,EAAA,KACAL,GAQA1R,YAAA,SAAAC,EAAAyR,GACA,IAAA1E,EAAAxQ,KAAAuF,QAAA,KACAkL,EAAAzQ,KAAAuF,QAAA,KAIA,OAHA2P,QACAA,EAAA,GAAA1E,EAAA7M,YAAA6M,EAAA5M,aAAAH,EAAA,KACAyR,EAAA,GAAAzE,EAAA9M,YAAA8M,EAAA7M,aAAAH,EAAA,KACAyR,GAOA5R,aAAA,SAAAW,GACA,OAAAjE,KAAAuF,QAAA,MAAAtB,EAAA5B,IAAA,WAGA3D,EAAAmF,SAAA+K,EAAAxJ,GACA,IAAAjG,EAAAyP,EACAxN,EAAAC,QAAAlC,wBCzHA,IAAAuW,EAAc/W,EAAQ,QAEtBD,EAAaC,EAAQ,QAErB+H,EAAc/H,EAAQ,QAEtBA,EAAQ,QAERA,EAAQ,QAqBR+W,EAAAC,qBACAhW,KAAA,OACAuH,OAAA,SAAAU,EAAA9H,GACAE,KAAAsH,MAAAC,YAEAK,EAAAvH,IAAA,SACAL,KAAAsH,MAAAK,IAAA,IAAAjB,EAAA4E,MACAtB,MAAApC,EAAArG,iBAAAqH,UACAyB,MAAA3L,EAAA4L,UACAiB,KAAA3D,EAAAvH,IAAA,oBACSuH,EAAAgO,gBACTpL,QAAA,EACAqL,IAAA,QAKAH,EAAAI,qBAAA,SAAAjW,GAEAA,EAAA2Q,OAAA3Q,EAAA4Q,QAAA5Q,EAAA0D,OACA1D,EAAA0D","file":"static/js/chunk-8eb261d8.cbad3e08.js","sourcesContent":["var zrUtil = require(\"zrender/lib/core/util\");\n\nvar axisDefault = require(\"./axisDefault\");\n\nvar ComponentModel = require(\"../model/Component\");\n\nvar _layout = require(\"../util/layout\");\n\nvar getLayoutParams = _layout.getLayoutParams;\nvar mergeLayoutParam = _layout.mergeLayoutParam;\n\nvar OrdinalMeta = require(\"../data/OrdinalMeta\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// FIXME axisType is fixed ?\nvar AXIS_TYPES = ['value', 'category', 'time', 'log'];\n/**\n * Generate sub axis model class\n * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n * @param {module:echarts/model/Component} BaseAxisModelClass\n * @param {Function} axisTypeDefaulter\n * @param {Object} [extraDefaultOption]\n */\n\nfunction _default(axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n  zrUtil.each(AXIS_TYPES, function (axisType) {\n    BaseAxisModelClass.extend({\n      /**\n       * @readOnly\n       */\n      type: axisName + 'Axis.' + axisType,\n      mergeDefaultAndTheme: function (option, ecModel) {\n        var layoutMode = this.layoutMode;\n        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};\n        var themeModel = ecModel.getTheme();\n        zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n        zrUtil.merge(option, this.getDefaultOption());\n        option.type = axisTypeDefaulter(axisName, option);\n\n        if (layoutMode) {\n          mergeLayoutParam(option, inputPositionParams, layoutMode);\n        }\n      },\n\n      /**\n       * @override\n       */\n      optionUpdated: function () {\n        var thisOption = this.option;\n\n        if (thisOption.type === 'category') {\n          this.__ordinalMeta = OrdinalMeta.createByAxisModel(this);\n        }\n      },\n\n      /**\n       * Should not be called before all of 'getInitailData' finished.\n       * Because categories are collected during initializing data.\n       */\n      getCategories: function (rawData) {\n        var option = this.option; // FIXME\n        // warning if called before all of 'getInitailData' finished.\n\n        if (option.type === 'category') {\n          if (rawData) {\n            return option.data;\n          }\n\n          return this.__ordinalMeta.categories;\n        }\n      },\n      getOrdinalMeta: function () {\n        return this.__ordinalMeta;\n      },\n      defaultOption: zrUtil.mergeAll([{}, axisDefault[axisType + 'Axis'], extraDefaultOption], true)\n    });\n  });\n  ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));\n}\n\nmodule.exports = _default;","require(\"./AxisModel\");\n\nvar ComponentModel = require(\"../../model/Component\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Grid 是在有直角坐标系的时候必须要存在的\n// 所以这里也要被 Cartesian2D 依赖\nvar _default = ComponentModel.extend({\n  type: 'grid',\n  dependencies: ['xAxis', 'yAxis'],\n  layoutMode: 'box',\n\n  /**\n   * @type {module:echarts/coord/cartesian/Grid}\n   */\n  coordinateSystem: null,\n  defaultOption: {\n    show: false,\n    zlevel: 0,\n    z: 0,\n    left: '10%',\n    top: 60,\n    right: '10%',\n    bottom: 60,\n    // If grid size contain label\n    containLabel: false,\n    // width: {totalWidth} - left - right,\n    // height: {totalHeight} - top - bottom,\n    backgroundColor: 'rgba(0,0,0,0)',\n    borderWidth: 1,\n    borderColor: '#ccc'\n  }\n});\n\nmodule.exports = _default;","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Axis = require(\"../Axis\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Extend axis 2d\n * @constructor module:echarts/coord/cartesian/Axis2D\n * @extends {module:echarts/coord/cartesian/Axis}\n * @param {string} dim\n * @param {*} scale\n * @param {Array.<number>} coordExtent\n * @param {string} axisType\n * @param {string} position\n */\nvar Axis2D = function (dim, scale, coordExtent, axisType, position) {\n  Axis.call(this, dim, scale, coordExtent);\n  /**\n   * Axis type\n   *  - 'category'\n   *  - 'value'\n   *  - 'time'\n   *  - 'log'\n   * @type {string}\n   */\n\n  this.type = axisType || 'value';\n  /**\n   * Axis position\n   *  - 'top'\n   *  - 'bottom'\n   *  - 'left'\n   *  - 'right'\n   */\n\n  this.position = position || 'bottom';\n};\n\nAxis2D.prototype = {\n  constructor: Axis2D,\n\n  /**\n   * Index of axis, can be used as key\n   */\n  index: 0,\n\n  /**\n   * Implemented in <module:echarts/coord/cartesian/Grid>.\n   * @return {Array.<module:echarts/coord/cartesian/Axis2D>}\n   *         If not on zero of other axis, return null/undefined.\n   *         If no axes, return an empty array.\n   */\n  getAxesOnZeroOf: null,\n\n  /**\n   * Axis model\n   * @param {module:echarts/coord/cartesian/AxisModel}\n   */\n  model: null,\n  isHorizontal: function () {\n    var position = this.position;\n    return position === 'top' || position === 'bottom';\n  },\n\n  /**\n   * Each item cooresponds to this.getExtent(), which\n   * means globalExtent[0] may greater than globalExtent[1],\n   * unless `asc` is input.\n   *\n   * @param {boolean} [asc]\n   * @return {Array.<number>}\n   */\n  getGlobalExtent: function (asc) {\n    var ret = this.getExtent();\n    ret[0] = this.toGlobalCoord(ret[0]);\n    ret[1] = this.toGlobalCoord(ret[1]);\n    asc && ret[0] > ret[1] && ret.reverse();\n    return ret;\n  },\n  getOtherAxis: function () {\n    this.grid.getOtherAxis();\n  },\n\n  /**\n   * @override\n   */\n  pointToData: function (point, clamp) {\n    return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);\n  },\n\n  /**\n   * Transform global coord to local coord,\n   * i.e. var localCoord = axis.toLocalCoord(80);\n   * designate by module:echarts/coord/cartesian/Grid.\n   * @type {Function}\n   */\n  toLocalCoord: null,\n\n  /**\n   * Transform global coord to local coord,\n   * i.e. var globalCoord = axis.toLocalCoord(40);\n   * designate by module:echarts/coord/cartesian/Grid.\n   * @type {Function}\n   */\n  toGlobalCoord: null\n};\nzrUtil.inherits(Axis2D, Axis);\nvar _default = Axis2D;\nmodule.exports = _default;","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar ComponentModel = require(\"../../model/Component\");\n\nvar axisModelCreator = require(\"../axisModelCreator\");\n\nvar axisModelCommonMixin = require(\"../axisModelCommonMixin\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar AxisModel = ComponentModel.extend({\n  type: 'cartesian2dAxis',\n\n  /**\n   * @type {module:echarts/coord/cartesian/Axis2D}\n   */\n  axis: null,\n\n  /**\n   * @override\n   */\n  init: function () {\n    AxisModel.superApply(this, 'init', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function () {\n    AxisModel.superApply(this, 'mergeOption', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   */\n  restoreData: function () {\n    AxisModel.superApply(this, 'restoreData', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   * @return {module:echarts/model/Component}\n   */\n  getCoordSysModel: function () {\n    return this.ecModel.queryComponents({\n      mainType: 'grid',\n      index: this.option.gridIndex,\n      id: this.option.gridId\n    })[0];\n  }\n});\n\nfunction getAxisType(axisDim, option) {\n  // Default axis with data is category axis\n  return option.type || (option.data ? 'category' : 'value');\n}\n\nzrUtil.merge(AxisModel.prototype, axisModelCommonMixin);\nvar extraOption = {\n  // gridIndex: 0,\n  // gridId: '',\n  // Offset is for multiple axis on the same position\n  offset: 0\n};\naxisModelCreator('x', AxisModel, getAxisType, extraOption);\naxisModelCreator('y', AxisModel, getAxisType, extraOption);\nvar _default = AxisModel;\nmodule.exports = _default;","var zrUtil = require(\"zrender/lib/core/util\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Cartesian coordinate system\n * @module  echarts/coord/Cartesian\n *\n */\nfunction dimAxisMapper(dim) {\n  return this._axes[dim];\n}\n/**\n * @alias module:echarts/coord/Cartesian\n * @constructor\n */\n\n\nvar Cartesian = function (name) {\n  this._axes = {};\n  this._dimList = [];\n  /**\n   * @type {string}\n   */\n\n  this.name = name || '';\n};\n\nCartesian.prototype = {\n  constructor: Cartesian,\n  type: 'cartesian',\n\n  /**\n   * Get axis\n   * @param  {number|string} dim\n   * @return {module:echarts/coord/Cartesian~Axis}\n   */\n  getAxis: function (dim) {\n    return this._axes[dim];\n  },\n\n  /**\n   * Get axes list\n   * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n   */\n  getAxes: function () {\n    return zrUtil.map(this._dimList, dimAxisMapper, this);\n  },\n\n  /**\n   * Get axes list by given scale type\n   */\n  getAxesByScale: function (scaleType) {\n    scaleType = scaleType.toLowerCase();\n    return zrUtil.filter(this.getAxes(), function (axis) {\n      return axis.scale.type === scaleType;\n    });\n  },\n\n  /**\n   * Add axis\n   * @param {module:echarts/coord/Cartesian.Axis}\n   */\n  addAxis: function (axis) {\n    var dim = axis.dim;\n    this._axes[dim] = axis;\n\n    this._dimList.push(dim);\n  },\n\n  /**\n   * Convert data to coord in nd space\n   * @param {Array.<number>|Object.<string, number>} val\n   * @return {Array.<number>|Object.<string, number>}\n   */\n  dataToCoord: function (val) {\n    return this._dataCoordConvert(val, 'dataToCoord');\n  },\n\n  /**\n   * Convert coord in nd space to data\n   * @param  {Array.<number>|Object.<string, number>} val\n   * @return {Array.<number>|Object.<string, number>}\n   */\n  coordToData: function (val) {\n    return this._dataCoordConvert(val, 'coordToData');\n  },\n  _dataCoordConvert: function (input, method) {\n    var dimList = this._dimList;\n    var output = input instanceof Array ? [] : {};\n\n    for (var i = 0; i < dimList.length; i++) {\n      var dim = dimList[i];\n      var axis = this._axes[dim];\n      output[dim] = axis[method](input[dim]);\n    }\n\n    return output;\n  }\n};\nvar _default = Cartesian;\nmodule.exports = _default;","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar AxisBuilder = require(\"./AxisBuilder\");\n\nvar AxisView = require(\"./AxisView\");\n\nvar cartesianAxisHelper = require(\"../../coord/cartesian/cartesianAxisHelper\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\nvar selfBuilderAttrs = ['splitArea', 'splitLine']; // function getAlignWithLabel(model, axisModel) {\n//     var alignWithLabel = model.get('alignWithLabel');\n//     if (alignWithLabel === 'auto') {\n//         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n//     }\n//     return alignWithLabel;\n// }\n\nvar CartesianAxisView = AxisView.extend({\n  type: 'cartesianAxis',\n  axisPointerClass: 'CartesianAxisPointer',\n\n  /**\n   * @override\n   */\n  render: function (axisModel, ecModel, api, payload) {\n    this.group.removeAll();\n    var oldAxisGroup = this._axisGroup;\n    this._axisGroup = new graphic.Group();\n    this.group.add(this._axisGroup);\n\n    if (!axisModel.get('show')) {\n      return;\n    }\n\n    var gridModel = axisModel.getCoordSysModel();\n    var layout = cartesianAxisHelper.layout(gridModel, axisModel);\n    var axisBuilder = new AxisBuilder(axisModel, layout);\n    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n    this._axisGroup.add(axisBuilder.getGroup());\n\n    zrUtil.each(selfBuilderAttrs, function (name) {\n      if (axisModel.get(name + '.show')) {\n        this['_' + name](axisModel, gridModel);\n      }\n    }, this);\n    graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n    CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);\n  },\n  remove: function () {\n    this._splitAreaColors = null;\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @private\n   */\n  _splitLine: function (axisModel, gridModel) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitLineModel = axisModel.getModel('splitLine');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var lineColors = lineStyleModel.get('color');\n    lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var isHorizontal = axis.isHorizontal();\n    var lineCount = 0;\n    var ticksCoords = axis.getTicksCoords({\n      tickModel: splitLineModel\n    });\n    var p1 = [];\n    var p2 = []; // Simple optimization\n    // Batching the lines if color are the same\n\n    var lineStyle = lineStyleModel.getLineStyle();\n\n    for (var i = 0; i < ticksCoords.length; i++) {\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);\n\n      if (isHorizontal) {\n        p1[0] = tickCoord;\n        p1[1] = gridRect.y;\n        p2[0] = tickCoord;\n        p2[1] = gridRect.y + gridRect.height;\n      } else {\n        p1[0] = gridRect.x;\n        p1[1] = tickCoord;\n        p2[0] = gridRect.x + gridRect.width;\n        p2[1] = tickCoord;\n      }\n\n      var colorIndex = lineCount++ % lineColors.length;\n      var tickValue = ticksCoords[i].tickValue;\n\n      this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n        anid: tickValue != null ? 'line_' + ticksCoords[i].tickValue : null,\n        shape: {\n          x1: p1[0],\n          y1: p1[1],\n          x2: p2[0],\n          y2: p2[1]\n        },\n        style: zrUtil.defaults({\n          stroke: lineColors[colorIndex]\n        }, lineStyle),\n        silent: true\n      })));\n    }\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @private\n   */\n  _splitArea: function (axisModel, gridModel) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitAreaModel = axisModel.getModel('splitArea');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var areaColors = areaStyleModel.get('color');\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var ticksCoords = axis.getTicksCoords({\n      tickModel: splitAreaModel,\n      clamp: true\n    });\n\n    if (!ticksCoords.length) {\n      return;\n    } // For Making appropriate splitArea animation, the color and anid\n    // should be corresponding to previous one if possible.\n\n\n    var areaColorsLen = areaColors.length;\n    var lastSplitAreaColors = this._splitAreaColors;\n    var newSplitAreaColors = zrUtil.createHashMap();\n    var colorIndex = 0;\n\n    if (lastSplitAreaColors) {\n      for (var i = 0; i < ticksCoords.length; i++) {\n        var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);\n\n        if (cIndex != null) {\n          colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;\n          break;\n        }\n      }\n    }\n\n    var prev = axis.toGlobalCoord(ticksCoords[0].coord);\n    var areaStyle = areaStyleModel.getAreaStyle();\n    areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\n    for (var i = 1; i < ticksCoords.length; i++) {\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (axis.isHorizontal()) {\n        x = prev;\n        y = gridRect.y;\n        width = tickCoord - x;\n        height = gridRect.height;\n        prev = x + width;\n      } else {\n        x = gridRect.x;\n        y = prev;\n        width = gridRect.width;\n        height = tickCoord - y;\n        prev = y + height;\n      }\n\n      var tickValue = ticksCoords[i - 1].tickValue;\n      tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);\n\n      this._axisGroup.add(new graphic.Rect({\n        anid: tickValue != null ? 'area_' + tickValue : null,\n        shape: {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        },\n        style: zrUtil.defaults({\n          fill: areaColors[colorIndex]\n        }, areaStyle),\n        silent: true\n      }));\n\n      colorIndex = (colorIndex + 1) % areaColorsLen;\n    }\n\n    this._splitAreaColors = newSplitAreaColors;\n  }\n});\nCartesianAxisView.extend({\n  type: 'xAxis'\n});\nCartesianAxisView.extend({\n  type: 'yAxis'\n});","var zrUtil = require(\"zrender/lib/core/util\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar defaultOption = {\n  show: true,\n  zlevel: 0,\n  z: 0,\n  // Inverse the axis.\n  inverse: false,\n  // Axis name displayed.\n  name: '',\n  // 'start' | 'middle' | 'end'\n  nameLocation: 'end',\n  // By degree. By defualt auto rotate by nameLocation.\n  nameRotate: null,\n  nameTruncate: {\n    maxWidth: null,\n    ellipsis: '...',\n    placeholder: '.'\n  },\n  // Use global text style by default.\n  nameTextStyle: {},\n  // The gap between axisName and axisLine.\n  nameGap: 15,\n  // Default `false` to support tooltip.\n  silent: false,\n  // Default `false` to avoid legacy user event listener fail.\n  triggerEvent: false,\n  tooltip: {\n    show: false\n  },\n  axisPointer: {},\n  axisLine: {\n    show: true,\n    onZero: true,\n    onZeroAxisIndex: null,\n    lineStyle: {\n      color: '#333',\n      width: 1,\n      type: 'solid'\n    },\n    // The arrow at both ends the the axis.\n    symbol: ['none', 'none'],\n    symbolSize: [10, 15]\n  },\n  axisTick: {\n    show: true,\n    // Whether axisTick is inside the grid or outside the grid.\n    inside: false,\n    // The length of axisTick.\n    length: 5,\n    lineStyle: {\n      width: 1\n    }\n  },\n  axisLabel: {\n    show: true,\n    // Whether axisLabel is inside the grid or outside the grid.\n    inside: false,\n    rotate: 0,\n    // true | false | null/undefined (auto)\n    showMinLabel: null,\n    // true | false | null/undefined (auto)\n    showMaxLabel: null,\n    margin: 8,\n    // formatter: null,\n    fontSize: 12\n  },\n  splitLine: {\n    show: true,\n    lineStyle: {\n      color: ['#ccc'],\n      width: 1,\n      type: 'solid'\n    }\n  },\n  splitArea: {\n    show: false,\n    areaStyle: {\n      color: ['rgba(250,250,250,0.3)', 'rgba(200,200,200,0.3)']\n    }\n  }\n};\nvar axisDefault = {};\naxisDefault.categoryAxis = zrUtil.merge({\n  // The gap at both ends of the axis. For categoryAxis, boolean.\n  boundaryGap: true,\n  // Set false to faster category collection.\n  // Only usefull in the case like: category is\n  // ['2012-01-01', '2012-01-02', ...], where the input\n  // data has been ensured not duplicate and is large data.\n  // null means \"auto\":\n  // if axis.data provided, do not deduplication,\n  // else do deduplication.\n  deduplication: null,\n  // splitArea: {\n  // show: false\n  // },\n  splitLine: {\n    show: false\n  },\n  axisTick: {\n    // If tick is align with label when boundaryGap is true\n    alignWithLabel: false,\n    interval: 'auto'\n  },\n  axisLabel: {\n    interval: 'auto'\n  }\n}, defaultOption);\naxisDefault.valueAxis = zrUtil.merge({\n  // The gap at both ends of the axis. For value axis, [GAP, GAP], where\n  // `GAP` can be an absolute pixel number (like `35`), or percent (like `'30%'`)\n  boundaryGap: [0, 0],\n  // TODO\n  // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]\n  // Min value of the axis. can be:\n  // + a number\n  // + 'dataMin': use the min value in data.\n  // + null/undefined: auto decide min value (consider pretty look and boundaryGap).\n  // min: null,\n  // Max value of the axis. can be:\n  // + a number\n  // + 'dataMax': use the max value in data.\n  // + null/undefined: auto decide max value (consider pretty look and boundaryGap).\n  // max: null,\n  // Readonly prop, specifies start value of the range when using data zoom.\n  // rangeStart: null\n  // Readonly prop, specifies end value of the range when using data zoom.\n  // rangeEnd: null\n  // Optional value can be:\n  // + `false`: always include value 0.\n  // + `true`: the extent do not consider value 0.\n  // scale: false,\n  // AxisTick and axisLabel and splitLine are caculated based on splitNumber.\n  splitNumber: 5 // Interval specifies the span of the ticks is mandatorily.\n  // interval: null\n  // Specify min interval when auto calculate tick interval.\n  // minInterval: null\n  // Specify max interval when auto calculate tick interval.\n  // maxInterval: null\n\n}, defaultOption);\naxisDefault.timeAxis = zrUtil.defaults({\n  scale: true,\n  min: 'dataMin',\n  max: 'dataMax'\n}, axisDefault.valueAxis);\naxisDefault.logAxis = zrUtil.defaults({\n  scale: true,\n  logBase: 10\n}, axisDefault.valueAxis);\nvar _default = axisDefault;\nmodule.exports = _default;","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar isObject = _util.isObject;\nvar each = _util.each;\nvar map = _util.map;\nvar indexOf = _util.indexOf;\nvar retrieve = _util.retrieve;\n\nvar _layout = require(\"../../util/layout\");\n\nvar getLayoutRect = _layout.getLayoutRect;\n\nvar _axisHelper = require(\"../../coord/axisHelper\");\n\nvar createScaleByModel = _axisHelper.createScaleByModel;\nvar ifAxisCrossZero = _axisHelper.ifAxisCrossZero;\nvar niceScaleExtent = _axisHelper.niceScaleExtent;\nvar estimateLabelUnionRect = _axisHelper.estimateLabelUnionRect;\n\nvar Cartesian2D = require(\"./Cartesian2D\");\n\nvar Axis2D = require(\"./Axis2D\");\n\nvar CoordinateSystem = require(\"../../CoordinateSystem\");\n\nvar _dataStackHelper = require(\"../../data/helper/dataStackHelper\");\n\nvar getStackedDimension = _dataStackHelper.getStackedDimension;\n\nrequire(\"./GridModel\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\n// Depends on GridModel, AxisModel, which performs preprocess.\n\n/**\n * Check if the axis is used in the specified grid\n * @inner\n */\nfunction isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\n\nfunction Grid(gridModel, ecModel, api) {\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n   * @private\n   */\n  this._coordsMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n   * @private\n   */\n\n  this._coordsList = [];\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesList = [];\n\n  this._initCartesian(gridModel, ecModel, api);\n\n  this.model = gridModel;\n}\n\nvar gridProto = Grid.prototype;\ngridProto.type = 'grid';\ngridProto.axisPointerEnabled = true;\n\ngridProto.getRect = function () {\n  return this._rect;\n};\n\ngridProto.update = function (ecModel, api) {\n  var axesMap = this._axesMap;\n\n  this._updateScale(ecModel, this.model);\n\n  each(axesMap.x, function (xAxis) {\n    niceScaleExtent(xAxis.scale, xAxis.model);\n  });\n  each(axesMap.y, function (yAxis) {\n    niceScaleExtent(yAxis.scale, yAxis.model);\n  });\n  each(axesMap.x, function (xAxis) {\n    fixAxisOnZero(axesMap, 'y', xAxis);\n  });\n  each(axesMap.y, function (yAxis) {\n    fixAxisOnZero(axesMap, 'x', yAxis);\n  }); // Resize again if containLabel is enabled\n  // FIXME It may cause getting wrong grid size in data processing stage\n\n  this.resize(this.model, api);\n};\n\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis) {\n  axis.getAxesOnZeroOf = function () {\n    // TODO: onZero of multiple axes.\n    return otherAxis ? [otherAxis] : [];\n  }; // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n\n\n  var otherAxes = axesMap[otherAxisDim];\n  var otherAxis;\n  var axisModel = axis.model;\n  var onZero = axisModel.get('axisLine.onZero');\n  var onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex');\n\n  if (!onZero) {\n    return;\n  } // If target axis is specified.\n\n\n  if (onZeroAxisIndex != null) {\n    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {\n      otherAxis = otherAxes[onZeroAxisIndex];\n    }\n\n    return;\n  } // Find the first available other axis.\n\n\n  for (var idx in otherAxes) {\n    if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx])) {\n      otherAxis = otherAxes[idx];\n      break;\n    }\n  }\n}\n\nfunction canOnZeroToAxis(axis) {\n  return axis && axis.type !== 'category' && axis.type !== 'time' && ifAxisCrossZero(axis);\n}\n/**\n * Resize the grid\n * @param {module:echarts/coord/cartesian/GridModel} gridModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\ngridProto.resize = function (gridModel, api, ignoreContainLabel) {\n  var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n  this._rect = gridRect;\n  var axesList = this._axesList;\n  adjustAxes(); // Minus label size\n\n  if (!ignoreContainLabel && gridModel.get('containLabel')) {\n    each(axesList, function (axis) {\n      if (!axis.model.get('axisLabel.inside')) {\n        var labelUnionRect = estimateLabelUnionRect(axis);\n\n        if (labelUnionRect) {\n          var dim = axis.isHorizontal() ? 'height' : 'width';\n          var margin = axis.model.get('axisLabel.margin');\n          gridRect[dim] -= labelUnionRect[dim] + margin;\n\n          if (axis.position === 'top') {\n            gridRect.y += labelUnionRect.height + margin;\n          } else if (axis.position === 'left') {\n            gridRect.x += labelUnionRect.width + margin;\n          }\n        }\n      }\n    });\n    adjustAxes();\n  }\n\n  function adjustAxes() {\n    each(axesList, function (axis) {\n      var isHorizontal = axis.isHorizontal();\n      var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n      var idx = axis.inverse ? 1 : 0;\n      axis.setExtent(extent[idx], extent[1 - idx]);\n      updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);\n    });\n  }\n};\n/**\n * @param {string} axisType\n * @param {number} [axisIndex]\n */\n\n\ngridProto.getAxis = function (axisType, axisIndex) {\n  var axesMapOnDim = this._axesMap[axisType];\n\n  if (axesMapOnDim != null) {\n    if (axisIndex == null) {\n      // Find first axis\n      for (var name in axesMapOnDim) {\n        if (axesMapOnDim.hasOwnProperty(name)) {\n          return axesMapOnDim[name];\n        }\n      }\n    }\n\n    return axesMapOnDim[axisIndex];\n  }\n};\n/**\n * @return {Array.<module:echarts/coord/Axis>}\n */\n\n\ngridProto.getAxes = function () {\n  return this._axesList.slice();\n};\n/**\n * Usage:\n *      grid.getCartesian(xAxisIndex, yAxisIndex);\n *      grid.getCartesian(xAxisIndex);\n *      grid.getCartesian(null, yAxisIndex);\n *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});\n *\n * @param {number|Object} [xAxisIndex]\n * @param {number} [yAxisIndex]\n */\n\n\ngridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n  if (xAxisIndex != null && yAxisIndex != null) {\n    var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n    return this._coordsMap[key];\n  }\n\n  if (isObject(xAxisIndex)) {\n    yAxisIndex = xAxisIndex.yAxisIndex;\n    xAxisIndex = xAxisIndex.xAxisIndex;\n  } // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\n\n  for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n    if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n      return coordList[i];\n    }\n  }\n};\n\ngridProto.getCartesians = function () {\n  return this._coordsList.slice();\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertToPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertFromPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n};\n/**\n * @inner\n */\n\n\ngridProto._findConvertTarget = function (ecModel, finder) {\n  var seriesModel = finder.seriesModel;\n  var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis')[0];\n  var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis')[0];\n  var gridModel = finder.gridModel;\n  var coordsList = this._coordsList;\n  var cartesian;\n  var axis;\n\n  if (seriesModel) {\n    cartesian = seriesModel.coordinateSystem;\n    indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n  } else if (xAxisModel && yAxisModel) {\n    cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  } else if (xAxisModel) {\n    axis = this.getAxis('x', xAxisModel.componentIndex);\n  } else if (yAxisModel) {\n    axis = this.getAxis('y', yAxisModel.componentIndex);\n  } // Lowest priority.\n  else if (gridModel) {\n      var grid = gridModel.coordinateSystem;\n\n      if (grid === this) {\n        cartesian = this._coordsList[0];\n      }\n    }\n\n  return {\n    cartesian: cartesian,\n    axis: axis\n  };\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.containPoint = function (point) {\n  var coord = this._coordsList[0];\n\n  if (coord) {\n    return coord.containPoint(point);\n  }\n};\n/**\n * Initialize cartesian coordinate systems\n * @private\n */\n\n\ngridProto._initCartesian = function (gridModel, ecModel, api) {\n  var axisPositionUsed = {\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  };\n  var axesMap = {\n    x: {},\n    y: {}\n  };\n  var axesCount = {\n    x: 0,\n    y: 0\n  }; /// Create axis\n\n  ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n  ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n  if (!axesCount.x || !axesCount.y) {\n    // Roll back when there no either x or y axis\n    this._axesMap = {};\n    this._axesList = [];\n    return;\n  }\n\n  this._axesMap = axesMap; /// Create cartesian2d\n\n  each(axesMap.x, function (xAxis, xAxisIndex) {\n    each(axesMap.y, function (yAxis, yAxisIndex) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      var cartesian = new Cartesian2D(key);\n      cartesian.grid = this;\n      cartesian.model = gridModel;\n      this._coordsMap[key] = cartesian;\n\n      this._coordsList.push(cartesian);\n\n      cartesian.addAxis(xAxis);\n      cartesian.addAxis(yAxis);\n    }, this);\n  }, this);\n\n  function createAxisCreator(axisType) {\n    return function (axisModel, idx) {\n      if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var axisPosition = axisModel.get('position');\n\n      if (axisType === 'x') {\n        // Fix position\n        if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n          // Default bottom of X\n          axisPosition = 'bottom';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n          }\n        }\n      } else {\n        // Fix position\n        if (axisPosition !== 'left' && axisPosition !== 'right') {\n          // Default left of Y\n          axisPosition = 'left';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n          }\n        }\n      }\n\n      axisPositionUsed[axisPosition] = true;\n      var axis = new Axis2D(axisType, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n      var isCategory = axis.type === 'category';\n      axis.onBand = isCategory && axisModel.get('boundaryGap');\n      axis.inverse = axisModel.get('inverse'); // Inject axis into axisModel\n\n      axisModel.axis = axis; // Inject axisModel into axis\n\n      axis.model = axisModel; // Inject grid info axis\n\n      axis.grid = this; // Index of axis, can be used as key\n\n      axis.index = idx;\n\n      this._axesList.push(axis);\n\n      axesMap[axisType][idx] = axis;\n      axesCount[axisType]++;\n    };\n  }\n};\n/**\n * Update cartesian properties from series\n * @param  {module:echarts/model/Option} option\n * @private\n */\n\n\ngridProto._updateScale = function (ecModel, gridModel) {\n  // Reset scale\n  each(this._axesList, function (axis) {\n    axis.scale.setExtent(Infinity, -Infinity);\n  });\n  ecModel.eachSeries(function (seriesModel) {\n    if (isCartesian2D(seriesModel)) {\n      var axesModels = findAxesModels(seriesModel, ecModel);\n      var xAxisModel = axesModels[0];\n      var yAxisModel = axesModels[1];\n\n      if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n      var data = seriesModel.getData();\n      var xAxis = cartesian.getAxis('x');\n      var yAxis = cartesian.getAxis('y');\n\n      if (data.type === 'list') {\n        unionExtent(data, xAxis, seriesModel);\n        unionExtent(data, yAxis, seriesModel);\n      }\n    }\n  }, this);\n\n  function unionExtent(data, axis, seriesModel) {\n    each(data.mapDimension(axis.dim, true), function (dim) {\n      axis.scale.unionExtentFromData( // For example, the extent of the orginal dimension\n      // is [0.1, 0.5], the extent of the `stackResultDimension`\n      // is [7, 9], the final extent should not include [0.1, 0.5].\n      data, getStackedDimension(data, dim));\n    });\n  }\n};\n/**\n * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined\n * @return {Object} {baseAxes: [], otherAxes: []}\n */\n\n\ngridProto.getTooltipAxes = function (dim) {\n  var baseAxes = [];\n  var otherAxes = [];\n  each(this.getCartesians(), function (cartesian) {\n    var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n    var otherAxis = cartesian.getOtherAxis(baseAxis);\n    indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n    indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n  });\n  return {\n    baseAxes: baseAxes,\n    otherAxes: otherAxes\n  };\n};\n/**\n * @inner\n */\n\n\nfunction updateAxisTransform(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform\n\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\n\nvar axesTypes = ['xAxis', 'yAxis'];\n/**\n * @inner\n */\n\nfunction findAxesModels(seriesModel, ecModel) {\n  return map(axesTypes, function (axisType) {\n    var axisModel = seriesModel.getReferringComponents(axisType)[0];\n    return axisModel;\n  });\n}\n/**\n * @inner\n */\n\n\nfunction isCartesian2D(seriesModel) {\n  return seriesModel.get('coordinateSystem') === 'cartesian2d';\n}\n\nGrid.create = function (ecModel, api) {\n  var grids = [];\n  ecModel.eachComponent('grid', function (gridModel, idx) {\n    var grid = new Grid(gridModel, ecModel, api);\n    grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize\n    // should be performed in create stage.\n\n    grid.resize(gridModel, api, true);\n    gridModel.coordinateSystem = grid;\n    grids.push(grid);\n  }); // Inject the coordinateSystems into seriesModel\n\n  ecModel.eachSeries(function (seriesModel) {\n    if (!isCartesian2D(seriesModel)) {\n      return;\n    }\n\n    var axesModels = findAxesModels(seriesModel, ecModel);\n    var xAxisModel = axesModels[0];\n    var yAxisModel = axesModels[1];\n    var gridModel = xAxisModel.getCoordSysModel();\n    var grid = gridModel.coordinateSystem;\n    seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  });\n  return grids;\n}; // For deciding which dimensions to use when creating list data\n\n\nGrid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;\nCoordinateSystem.register('cartesian2d', Grid);\nvar _default = Grid;\nmodule.exports = _default;","require(\"../coord/cartesian/AxisModel\");\n\nrequire(\"./axis/CartesianAxisView\");","var _dataProvider = require(\"../../data/helper/dataProvider\");\n\nvar retrieveRawValue = _dataProvider.retrieveRawValue;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @param {module:echarts/data/List} data\n * @param {number} dataIndex\n * @return {string} label string. Not null/undefined\n */\nfunction getDefaultLabel(data, dataIndex) {\n  var labelDims = data.mapDimension('defaultedLabel', true);\n  var len = labelDims.length; // Simple optimization (in lots of cases, label dims length is 1)\n\n  if (len === 1) {\n    return retrieveRawValue(data, dataIndex, labelDims[0]);\n  } else if (len) {\n    var vals = [];\n\n    for (var i = 0; i < labelDims.length; i++) {\n      var val = retrieveRawValue(data, dataIndex, labelDims[i]);\n      vals.push(val);\n    }\n\n    return vals.join(' ');\n  }\n}\n\nexports.getDefaultLabel = getDefaultLabel;","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Cartesian = require(\"./Cartesian\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction Cartesian2D(name) {\n  Cartesian.call(this, name);\n}\n\nCartesian2D.prototype = {\n  constructor: Cartesian2D,\n  type: 'cartesian2d',\n\n  /**\n   * @type {Array.<string>}\n   * @readOnly\n   */\n  dimensions: ['x', 'y'],\n\n  /**\n   * Base axis will be used on stacking.\n   *\n   * @return {module:echarts/coord/cartesian/Axis2D}\n   */\n  getBaseAxis: function () {\n    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n  },\n\n  /**\n   * If contain point\n   * @param {Array.<number>} point\n   * @return {boolean}\n   */\n  containPoint: function (point) {\n    var axisX = this.getAxis('x');\n    var axisY = this.getAxis('y');\n    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n  },\n\n  /**\n   * If contain data\n   * @param {Array.<number>} data\n   * @return {boolean}\n   */\n  containData: function (data) {\n    return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n  },\n\n  /**\n   * @param {Array.<number>} data\n   * @param {Array.<number>} out\n   * @return {Array.<number>}\n   */\n  dataToPoint: function (data, reserved, out) {\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    out = out || [];\n    out[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(data[0]));\n    out[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(data[1]));\n    return out;\n  },\n\n  /**\n   * @param {Array.<number>} data\n   * @param {Array.<number>} out\n   * @return {Array.<number>}\n   */\n  clampData: function (data, out) {\n    var xScale = this.getAxis('x').scale;\n    var yScale = this.getAxis('y').scale;\n    var xAxisExtent = xScale.getExtent();\n    var yAxisExtent = yScale.getExtent();\n    var x = xScale.parse(data[0]);\n    var y = yScale.parse(data[1]);\n    out = out || [];\n    out[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));\n    out[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));\n    return out;\n  },\n\n  /**\n   * @param {Array.<number>} point\n   * @param {Array.<number>} out\n   * @return {Array.<number>}\n   */\n  pointToData: function (point, out) {\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    out = out || [];\n    out[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]));\n    out[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]));\n    return out;\n  },\n\n  /**\n   * Get other axis\n   * @param {module:echarts/coord/cartesian/Axis2D} axis\n   */\n  getOtherAxis: function (axis) {\n    return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n  }\n};\nzrUtil.inherits(Cartesian2D, Cartesian);\nvar _default = Cartesian2D;\nmodule.exports = _default;","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../util/graphic\");\n\nrequire(\"../coord/cartesian/Grid\");\n\nrequire(\"./axis\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Grid view\necharts.extendComponentView({\n  type: 'grid',\n  render: function (gridModel, ecModel) {\n    this.group.removeAll();\n\n    if (gridModel.get('show')) {\n      this.group.add(new graphic.Rect({\n        shape: gridModel.coordinateSystem.getRect(),\n        style: zrUtil.defaults({\n          fill: gridModel.get('backgroundColor')\n        }, gridModel.getItemStyle()),\n        silent: true,\n        z2: -1\n      }));\n    }\n  }\n});\necharts.registerPreprocessor(function (option) {\n  // Only create grid when need\n  if (option.xAxis && option.yAxis && !option.grid) {\n    option.grid = {};\n  }\n});"],"sourceRoot":""}