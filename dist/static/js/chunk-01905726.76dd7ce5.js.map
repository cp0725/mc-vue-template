{"version":3,"sources":["webpack:///./node_modules/_echarts@4.1.0@echarts/lib/chart/line/helper.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/chart/line/lineAnimationDiff.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/processor/dataSample.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/chart/line/LineSeries.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/visual/symbol.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/chart/helper/SymbolDraw.js","webpack:///./node_modules/_v-charts@1.18.0@v-charts/lib/line.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/chart/line/poly.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/chart/line/LineView.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/chart/line.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/layout/points.js","webpack:///./node_modules/_echarts@4.1.0@echarts/lib/chart/helper/Symbol.js"],"names":["_dataStackHelper","__webpack_require__","isDimensionStacked","_util","map","prepareDataCoordInfo","coordSys","data","valueOrigin","stacked","baseAxis","getBaseAxis","valueAxis","getOtherAxis","valueStart","getValueStart","baseAxisDim","dim","valueAxisDim","valueDim","mapDimension","baseDim","baseDataOffset","dims","dimensions","coordDim","stackResultDim","getCalculationInfo","dataDimsForPoint","stackedOverDimension","extent","scale","getExtent","getStackedOnPoint","dataCoordInfo","idx","value","NaN","get","isNaN","stackedData","dataToPoint","exports","_helper","diffData","oldData","newData","diffResult","diff","add","push","cmd","update","newIdx","oldIdx","idx1","remove","execute","_default","oldStackedOnPoints","newStackedOnPoints","oldCoordSys","newCoordSys","oldValueOrigin","newValueOrigin","currPoints","nextPoints","currStackedPoints","nextStackedPoints","status","sortedIndices","rawIndices","newDataOldCoordInfo","oldDataNewCoordInfo","i","length","diffItem","pointAdded","currentPt","getItemLayout","nextPt","slice","getRawIndex","rawIndex","sort","a","b","sortedCurrPoints","sortedNextPoints","sortedCurrStackedPoints","sortedNextStackedPoints","sortedStatus","current","next","stackedOnCurrent","stackedOnNext","module","samplers","average","frame","sum","count","max","Infinity","isFinite","min","nearest","indexSampler","Math","round","seriesType","modifyOutputEnd","reset","seriesModel","ecModel","api","getData","sampling","coordinateSystem","type","sampler","size","rate","setData","downSample","_config","createListFromArray","__DEV__","SeriesModel","extend","dependencies","getInitialData","option","this","getSource","defaultOption","zlevel","z","legendHoverLink","hoverAnimation","clipOverflow","label","position","lineStyle","width","step","smooth","smoothMonotone","symbol","symbolSize","symbolRotate","showSymbol","showAllSymbol","connectNulls","animationEasing","progressive","hoverLayerThreshold","defaultSymbolType","legendSymbol","performRawSeries","symbolType","keepAspect","setVisual","symbolKeepAspect","isSeriesFiltered","hasCallback","dataEach","hasItemOption","rawValue","getRawValue","params","getDataParams","setItemVisual","itemModel","getItemModel","itemSymbolType","getShallow","itemSymbolSize","itemSymbolKeepAspect","graphic","SymbolClz","isObject","SymbolDraw","symbolCtor","group","Group","_symbolCtor","symbolDrawProto","prototype","symbolNeedsDraw","point","opt","isIgnore","clipShape","contain","getItemVisual","normalizeUpdateOpt","makeSeriesScope","hostModel","itemStyle","getModel","getItemStyle","hoverItemStyle","symbolOffset","labelModel","hoverLabelModel","cursorStyle","updateData","_data","SymbolCtor","seriesScope","removeAll","symbolEl","attr","setItemGraphicEl","getItemGraphicEl","updateProps","el","fadeOut","isPersistent","updateLayout","eachItemGraphicEl","incrementalPrepareUpdate","_seriesScope","incrementalUpdate","taskParams","updateIncrementalAndHover","isGroup","incremental","useHoverLayer","start","end","traverse","enableAnimation","global","factory","echartsLib","hasOwnProperty","ABBR","th","mi","bi","tr","DEFAULT_OPTIONS","zeroFormat","nullFormat","defaultFormat","scalePercentBy100","abbrLabel","TRILLION","BILLION","MILLION","THOUSAND","numIsNaN","toFixed","maxDecimals","roundingFunction","optionals","splitValue","toString","split","minDecimals","boundedPrecision","power","pow","output","optionalsRegExp","RegExp","replace","numberToFormat","options","format","abs","negP","optDec","abbr","decimal","neg","abbrForce","signed","indexOf","match","int","precision","thousands","leadingCount","trillion","million","target","sub","Object","keys","forEach","key","numerifyPercent","regexp","formatType","numerify","space","_numberToFormat","splice","join","formats","formatFunction","kind","bind","input","register","name","unregister","setOptions","opts","_typeof","Symbol","iterator","obj","constructor","_extends","assign","arguments","source","call","debounce","fn","delay","timer","self","args","clearTimeout","setTimeout","apply","set$1","path","targetTemp","pathArr","item","index","_typeof$1","getType","v","getTypeof","isArray","isFunction","cloneDeep","JSON","parse","stringify","camelToKebab","s","toLowerCase","hasOwn","isEqual","alice","bob","aliceValue","bobValue","aliceType","_key","getFormated","val","digit","defaultVal","undefined","digitStr","Array","formatter","getStackMap","stack","stackMap","getLineXAxis","dimension","rows","xAxisName","axisVisible","xAxisType","nameLocation","nameGap","axisTick","show","color","row","getLineSeries","axisSite","metrics","area","nullAddZero","labelMap","areaStyle","series","dataTemp","seriesItem","normal","right","yAxisIndex","getLineYAxis","yAxisName","yAxisType","yAxisBase","yAxis","_loop","axisLabel","getLineTooltip","tooltipFormatter","rightItems","rightList","trigger","items","tpl","_items$","axisValueLabel","title","_ref","seriesName","marker","showData","itemData","getLegend","legendName","line$1","columns","settings","extra","_settings$axisSite","_settings$yAxisType","_settings$xAxisType","_settings$yAxisName","_settings$dimension","_settings$xAxisName","_settings$axisVisible","_settings$scale","_settings$min","_settings$max","_settings$nullAddZero","_settings$digit","_settings$legendName","_settings$labelMap","tooltipVisible","legendVisible","left","concat","legend$$1","tooltip$$1","xAxis","legend","tooltip","Loading","render","_vm","_h","$createElement","_c","_self","staticClass","attrs","viewBox","cx","cy","r","fill","staticRenderFns","DataEmpty","_v","DEFAULT_THEME","categoryAxis","axisLine","splitLine","line","grid","containLabel","DEFAULT_COLORS","STATIC_PROPS","ECHARTS_SETTINGS","setExtend","setMark","marks","setAnimation","animation","Core","h","class","$options","_componentTag","style","canvasStyle","v-charts-mask-status","dataEmpty","loading","ref","display","$slots","default","props","String","height","beforeConfig","Function","afterConfig","afterSetOption","afterSetOptionOnce","events","colors","Boolean","legendPosition","markLine","markArea","markPoint","visualMap","dataZoom","toolbox","initOptions","radar","axisPointer","brush","geo","timeline","backgroundColor","textStyle","theme","themeName","judgeWidth","widthChangeDelay","Number","resizeable","resizeDelay","changeDelay","setOptionOpts","cancelResizeCheck","notSetUnchange","log","watch","deep","handler","changeHandler","chartLib","chartHandler","computed","chartColor","methods","dataHandler","_data$columns","_data$rows","echarts","_once","then","optionsHandler","nextTickResize","$nextTick","resize","echartsResize","$el","clientWidth","clientHeight","_this","top","orient","setting","bmap","amap","_store","notMerge","_isDestroyed","console","setOption","$emit","judgeWidthHandler","_this2","_","warn","resizeableHandler","onresize","addResizeListener","removeResizeListener","init","$refs","canvas","createEventProxy","window","addEventListener","resizeHandler","removeEventListener","addWatchToProps","_this3","watchedVariable","_watchers","watcher","expression","$props","prop","$watch","_this4","ev","registeredEvents","on","_len","themeChange","clean","dispose","created","mounted","beforeDestroy","_numerify","Path","vec2","fixClipWithShadow","vec2Min","vec2Max","scaleAndAdd","v2Copy","copy","cp0","cp1","isPointNull","p","drawSegment","ctx","points","segLen","allLen","dir","smoothMin","smoothMax","drawMono","drawNonMono","prevIdx","k","prevP","ctrlLen","bezierCurveTo","lineTo","nextIdx","nextP","ratioNextSeg","lenPrevSeg","lenNextSeg","dist","getBoundingBox","smoothConstraint","ptMin","ptMax","pt","Polyline","shape","stroke","buildPath","len","result","Polygon","stackedOnPoints","stackedOnSmooth","bbox","stackedOnBBox","closePath","zrUtil","lineAnimationDiff","modelUtil","_poly","ChartView","_number","isPointsSame","points1","points2","p1","p2","getSmooth","getAxisExtentWithGap","axis","getGlobalExtent","onBand","halfBandWidth","getBandWidth","getStackedOnPoints","createGridClipShape","cartesian","hasAnimation","forSymbol","xExtent","getAxis","yExtent","isHorizontal","x","y","lineWidth","expandSize","clipPath","Rect","initProps","createPolarClipShape","polar","angleAxis","getAngleAxis","radiusAxis","getRadiusAxis","radiusExtent","reverse","angleExtent","RADIAN","PI","Sector","r0","startAngle","endAngle","clockwise","inverse","createClipShape","turnPointsIntoStep","stepTurnAt","baseIndex","stepPoints","stepPt","middle","stepPt2","getVisualGradient","visualMetaList","getVisual","visualMeta","dimIndex","dimName","dimInfo","getDimensionInfo","colorStops","stops","stop","coord","toGlobalCoord","dataToCoord","stopLen","outerColors","tinyExtent","minCoord","maxCoord","coordSpan","each","offset","unshift","gradient","LinearGradient","getIsIgnoreFunc","isAuto","getAxesByScale","canShowAllSymbolForCategory","categoryDataDim","getViewLabels","labelItem","tickValue","dataIndex","axisExtent","availSize","dataLen","getSymbolSize","lineGroup","symbolDraw","_symbolDraw","_lineGroup","lineStyleModel","areaStyleModel","mapArray","isCoordSysPolar","prevCoordSys","_coordSys","polyline","_polyline","polygon","_polygon","isAreaChart","isEmpty","isIgnoreFunc","__temp","_step","_newPolygon","setClipPath","stopAnimation","_stackedOnPoints","_points","_updateAnimation","setShape","_newPolyline","visualColor","useStyle","defaults","getLineStyle","lineJoin","stackedOnSeries","getAreaStyle","opacity","_valueOrigin","highlight","payload","queryDataIndex","setZ","ignore","stopSymbolAnimation","downplay","silent","z2","__points","updatedDataInfo","diffStatus","ptIdx","animators","during","visualSymbol","layoutPoints","dataSample","registerVisual","registerLayout","registerProcessor","PRIORITY","PROCESSOR","STATISTIC","createRenderPlanner","plan","pipelineContext","isLargeRender","large","dimLen","progress","segCount","Float32Array","tmpIn","tmpOut","setItemLayout","setLayout","_symbol","createSymbol","parsePercent","_labelHelper","getDefaultLabel","symbolProto","getScale","driftSymbol","dx","dy","parent","drift","_createSymbol","symbolPath","culling","_symbolType","toLastFrame","childAt","getSymbolPath","setDraggable","draggable","cursor","isInit","_updateCommon","fadeIn","_seriesModel","normalStyleAccessPath","emphasisStyleAccessPath","normalLabelAccessPath","emphasisLabelAccessPath","strokeNoScale","elStyle","setColor","symbolInnerColor","setStyle","liftZ","z2Origin","__z2Origin","useNameLabel","getLabelDefaultText","getName","setLabelStyle","labelFetcher","labelDataIndex","defaultText","isRectText","autoColor","off","hoverStyle","setHoverStyle","isAnimationEnabled","onEmphasis","ratio","animateTo","onNormal","cb","keepLabel","text","inherits"],"mappings":"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","file":"static/js/chunk-01905726.76dd7ce5.js","sourcesContent":["var _dataStackHelper = require(\"../../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar map = _util.map;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @param {Object} coordSys\n * @param {module:echarts/data/List} data\n * @param {string} valueOrigin lineSeries.option.areaStyle.origin\n */\nfunction prepareDataCoordInfo(coordSys, data, valueOrigin) {\n  var baseAxis = coordSys.getBaseAxis();\n  var valueAxis = coordSys.getOtherAxis(baseAxis);\n  var valueStart = getValueStart(valueAxis, valueOrigin);\n  var baseAxisDim = baseAxis.dim;\n  var valueAxisDim = valueAxis.dim;\n  var valueDim = data.mapDimension(valueAxisDim);\n  var baseDim = data.mapDimension(baseAxisDim);\n  var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;\n  var dims = map(coordSys.dimensions, function (coordDim) {\n    return data.mapDimension(coordDim);\n  });\n  var stacked;\n  var stackResultDim = data.getCalculationInfo('stackResultDimension');\n\n  if (stacked |= isDimensionStacked(data, dims[0]\n  /*, dims[1]*/\n  )) {\n    // jshint ignore:line\n    dims[0] = stackResultDim;\n  }\n\n  if (stacked |= isDimensionStacked(data, dims[1]\n  /*, dims[0]*/\n  )) {\n    // jshint ignore:line\n    dims[1] = stackResultDim;\n  }\n\n  return {\n    dataDimsForPoint: dims,\n    valueStart: valueStart,\n    valueAxisDim: valueAxisDim,\n    baseAxisDim: baseAxisDim,\n    stacked: !!stacked,\n    valueDim: valueDim,\n    baseDim: baseDim,\n    baseDataOffset: baseDataOffset,\n    stackedOverDimension: data.getCalculationInfo('stackedOverDimension')\n  };\n}\n\nfunction getValueStart(valueAxis, valueOrigin) {\n  var valueStart = 0;\n  var extent = valueAxis.scale.getExtent();\n\n  if (valueOrigin === 'start') {\n    valueStart = extent[0];\n  } else if (valueOrigin === 'end') {\n    valueStart = extent[1];\n  } // auto\n  else {\n      // Both positive\n      if (extent[0] > 0) {\n        valueStart = extent[0];\n      } // Both negative\n      else if (extent[1] < 0) {\n          valueStart = extent[1];\n        } // If is one positive, and one negative, onZero shall be true\n\n    }\n\n  return valueStart;\n}\n\nfunction getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {\n  var value = NaN;\n\n  if (dataCoordInfo.stacked) {\n    value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);\n  }\n\n  if (isNaN(value)) {\n    value = dataCoordInfo.valueStart;\n  }\n\n  var baseDataOffset = dataCoordInfo.baseDataOffset;\n  var stackedData = [];\n  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);\n  stackedData[1 - baseDataOffset] = value;\n  return coordSys.dataToPoint(stackedData);\n}\n\nexports.prepareDataCoordInfo = prepareDataCoordInfo;\nexports.getStackedOnPoint = getStackedOnPoint;","var _helper = require(\"./helper\");\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// var arrayDiff = require('zrender/src/core/arrayDiff');\n// 'zrender/src/core/arrayDiff' has been used before, but it did\n// not do well in performance when roam with fixed dataZoom window.\n// function convertToIntId(newIdList, oldIdList) {\n//     // Generate int id instead of string id.\n//     // Compare string maybe slow in score function of arrDiff\n//     // Assume id in idList are all unique\n//     var idIndicesMap = {};\n//     var idx = 0;\n//     for (var i = 0; i < newIdList.length; i++) {\n//         idIndicesMap[newIdList[i]] = idx;\n//         newIdList[i] = idx++;\n//     }\n//     for (var i = 0; i < oldIdList.length; i++) {\n//         var oldId = oldIdList[i];\n//         // Same with newIdList\n//         if (idIndicesMap[oldId]) {\n//             oldIdList[i] = idIndicesMap[oldId];\n//         }\n//         else {\n//             oldIdList[i] = idx++;\n//         }\n//     }\n// }\nfunction diffData(oldData, newData) {\n  var diffResult = [];\n  newData.diff(oldData).add(function (idx) {\n    diffResult.push({\n      cmd: '+',\n      idx: idx\n    });\n  }).update(function (newIdx, oldIdx) {\n    diffResult.push({\n      cmd: '=',\n      idx: oldIdx,\n      idx1: newIdx\n    });\n  }).remove(function (idx) {\n    diffResult.push({\n      cmd: '-',\n      idx: idx\n    });\n  }).execute();\n  return diffResult;\n}\n\nfunction _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {\n  var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);\n  // var oldIdList = oldData.mapArray(oldData.getId);\n  // convertToIntId(newIdList, oldIdList);\n  // // FIXME One data ?\n  // diff = arrayDiff(oldIdList, newIdList);\n\n  var currPoints = [];\n  var nextPoints = []; // Points for stacking base line\n\n  var currStackedPoints = [];\n  var nextStackedPoints = [];\n  var status = [];\n  var sortedIndices = [];\n  var rawIndices = [];\n  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);\n  var oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);\n\n  for (var i = 0; i < diff.length; i++) {\n    var diffItem = diff[i];\n    var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast\n    // Which is in case remvoing or add more than one data in the tail or head\n\n    switch (diffItem.cmd) {\n      case '=':\n        var currentPt = oldData.getItemLayout(diffItem.idx);\n        var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly\n\n        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n          currentPt = nextPt.slice();\n        }\n\n        currPoints.push(currentPt);\n        nextPoints.push(nextPt);\n        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n        rawIndices.push(newData.getRawIndex(diffItem.idx1));\n        break;\n\n      case '+':\n        var idx = diffItem.idx;\n        currPoints.push(oldCoordSys.dataToPoint([newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx)]));\n        nextPoints.push(newData.getItemLayout(idx).slice());\n        currStackedPoints.push(getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, idx));\n        nextStackedPoints.push(newStackedOnPoints[idx]);\n        rawIndices.push(newData.getRawIndex(idx));\n        break;\n\n      case '-':\n        var idx = diffItem.idx;\n        var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue\n        // FIXME FIXME FIXME\n\n        if (rawIndex !== idx) {\n          currPoints.push(oldData.getItemLayout(idx));\n          nextPoints.push(newCoordSys.dataToPoint([oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx)]));\n          currStackedPoints.push(oldStackedOnPoints[idx]);\n          nextStackedPoints.push(getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, idx));\n          rawIndices.push(rawIndex);\n        } else {\n          pointAdded = false;\n        }\n\n    } // Original indices\n\n\n    if (pointAdded) {\n      status.push(diffItem);\n      sortedIndices.push(sortedIndices.length);\n    }\n  } // Diff result may be crossed if all items are changed\n  // Sort by data index\n\n\n  sortedIndices.sort(function (a, b) {\n    return rawIndices[a] - rawIndices[b];\n  });\n  var sortedCurrPoints = [];\n  var sortedNextPoints = [];\n  var sortedCurrStackedPoints = [];\n  var sortedNextStackedPoints = [];\n  var sortedStatus = [];\n\n  for (var i = 0; i < sortedIndices.length; i++) {\n    var idx = sortedIndices[i];\n    sortedCurrPoints[i] = currPoints[idx];\n    sortedNextPoints[i] = nextPoints[idx];\n    sortedCurrStackedPoints[i] = currStackedPoints[idx];\n    sortedNextStackedPoints[i] = nextStackedPoints[idx];\n    sortedStatus[i] = status[idx];\n  }\n\n  return {\n    current: sortedCurrPoints,\n    next: sortedNextPoints,\n    stackedOnCurrent: sortedCurrStackedPoints,\n    stackedOnNext: sortedNextStackedPoints,\n    status: sortedStatus\n  };\n}\n\nmodule.exports = _default;","/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar samplers = {\n  average: function (frame) {\n    var sum = 0;\n    var count = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      if (!isNaN(frame[i])) {\n        sum += frame[i];\n        count++;\n      }\n    } // Return NaN if count is 0\n\n\n    return count === 0 ? NaN : sum / count;\n  },\n  sum: function (frame) {\n    var sum = 0;\n\n    for (var i = 0; i < frame.length; i++) {\n      // Ignore NaN\n      sum += frame[i] || 0;\n    }\n\n    return sum;\n  },\n  max: function (frame) {\n    var max = -Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] > max && (max = frame[i]);\n    } // NaN will cause illegal axis extent.\n\n\n    return isFinite(max) ? max : NaN;\n  },\n  min: function (frame) {\n    var min = Infinity;\n\n    for (var i = 0; i < frame.length; i++) {\n      frame[i] < min && (min = frame[i]);\n    } // NaN will cause illegal axis extent.\n\n\n    return isFinite(min) ? min : NaN;\n  },\n  // TODO\n  // Median\n  nearest: function (frame) {\n    return frame[0];\n  }\n};\n\nvar indexSampler = function (frame, value) {\n  return Math.round(frame.length / 2);\n};\n\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    modifyOutputEnd: true,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var sampling = seriesModel.get('sampling');\n      var coordSys = seriesModel.coordinateSystem; // Only cartesian2d support down sampling\n\n      if (coordSys.type === 'cartesian2d' && sampling) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var extent = baseAxis.getExtent(); // Coordinste system has been resized\n\n        var size = extent[1] - extent[0];\n        var rate = Math.round(data.count() / size);\n\n        if (rate > 1) {\n          var sampler;\n\n          if (typeof sampling === 'string') {\n            sampler = samplers[sampling];\n          } else if (typeof sampling === 'function') {\n            sampler = sampling;\n          }\n\n          if (sampler) {\n            // Only support sample the first dim mapped from value axis.\n            seriesModel.setData(data.downSample(data.mapDimension(valueAxis.dim), 1 / rate, sampler, indexSampler));\n          }\n        }\n      }\n    }\n  };\n}\n\nmodule.exports = _default;","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar createListFromArray = require(\"../helper/createListFromArray\");\n\nvar SeriesModel = require(\"../../model/Series\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _default = SeriesModel.extend({\n  type: 'series.line',\n  dependencies: ['grid', 'polar'],\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(this.getSource(), this);\n  },\n  defaultOption: {\n    zlevel: 0,\n    z: 2,\n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    hoverAnimation: true,\n    // stack: null\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // polarIndex: 0,\n    // If clip the overflow value\n    clipOverflow: true,\n    // cursor: null,\n    label: {\n      position: 'top'\n    },\n    // itemStyle: {\n    // },\n    lineStyle: {\n      width: 2,\n      type: 'solid'\n    },\n    // areaStyle: {\n    // origin of areaStyle. Valid values:\n    // `'auto'/null/undefined`: from axisLine to data\n    // `'start'`: from min to data\n    // `'end'`: from data to max\n    // origin: 'auto'\n    // },\n    // false, 'start', 'end', 'middle'\n    step: false,\n    // Disabled if step is true\n    smooth: false,\n    smoothMonotone: null,\n    symbol: 'emptyCircle',\n    symbolSize: 4,\n    symbolRotate: null,\n    showSymbol: true,\n    // `false`: follow the label interval strategy.\n    // `true`: show all symbols.\n    // `'auto'`: If possible, show all symbols, otherwise\n    //           follow the label interval strategy.\n    showAllSymbol: 'auto',\n    // Whether to connect break point.\n    connectNulls: false,\n    // Sampling for large data. Can be: 'average', 'max', 'min', 'sum'.\n    sampling: 'none',\n    animationEasing: 'linear',\n    // Disable progressive\n    progressive: 0,\n    hoverLayerThreshold: Infinity\n  }\n});\n\nmodule.exports = _default;","/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(seriesType, defaultSymbolType, legendSymbol) {\n  // Encoding visual for all series include which is filtered for legend drawing\n  return {\n    seriesType: seriesType,\n    // For legend.\n    performRawSeries: true,\n    reset: function (seriesModel, ecModel, api) {\n      var data = seriesModel.getData();\n      var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n      var symbolSize = seriesModel.get('symbolSize');\n      var keepAspect = seriesModel.get('symbolKeepAspect');\n      data.setVisual({\n        legendSymbol: legendSymbol || symbolType,\n        symbol: symbolType,\n        symbolSize: symbolSize,\n        symbolKeepAspect: keepAspect\n      }); // Only visible series has each data be visual encoded\n\n      if (ecModel.isSeriesFiltered(seriesModel)) {\n        return;\n      }\n\n      var hasCallback = typeof symbolSize === 'function';\n\n      function dataEach(data, idx) {\n        if (typeof symbolSize === 'function') {\n          var rawValue = seriesModel.getRawValue(idx); // FIXME\n\n          var params = seriesModel.getDataParams(idx);\n          data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n        }\n\n        if (data.hasItemOption) {\n          var itemModel = data.getItemModel(idx);\n          var itemSymbolType = itemModel.getShallow('symbol', true);\n          var itemSymbolSize = itemModel.getShallow('symbolSize', true);\n          var itemSymbolKeepAspect = itemModel.getShallow('symbolKeepAspect', true); // If has item symbol\n\n          if (itemSymbolType != null) {\n            data.setItemVisual(idx, 'symbol', itemSymbolType);\n          }\n\n          if (itemSymbolSize != null) {\n            // PENDING Transform symbolSize ?\n            data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n          }\n\n          if (itemSymbolKeepAspect != null) {\n            data.setItemVisual(idx, 'symbolKeepAspect', itemSymbolKeepAspect);\n          }\n        }\n      }\n\n      return {\n        dataEach: data.hasItemOption || hasCallback ? dataEach : null\n      };\n    }\n  };\n}\n\nmodule.exports = _default;","var graphic = require(\"../../util/graphic\");\n\nvar SymbolClz = require(\"./Symbol\");\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar isObject = _util.isObject;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n/**\n * @constructor\n * @alias module:echarts/chart/helper/SymbolDraw\n * @param {module:zrender/graphic/Group} [symbolCtor]\n */\nfunction SymbolDraw(symbolCtor) {\n  this.group = new graphic.Group();\n  this._symbolCtor = symbolCtor || SymbolClz;\n}\n\nvar symbolDrawProto = SymbolDraw.prototype;\n\nfunction symbolNeedsDraw(data, point, idx, opt) {\n  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) // We do not set clipShape on group, because it will cut part of\n  // the symbol element shape. We use the same clip shape here as\n  // the line clip.\n  && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';\n}\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.updateData = function (data, opt) {\n  opt = normalizeUpdateOpt(opt);\n  var group = this.group;\n  var seriesModel = data.hostModel;\n  var oldData = this._data;\n  var SymbolCtor = this._symbolCtor;\n  var seriesScope = makeSeriesScope(data); // There is no oldLineData only when first rendering or switching from\n  // stream mode to normal mode, where previous elements should be removed.\n\n  if (!oldData) {\n    group.removeAll();\n  }\n\n  data.diff(oldData).add(function (newIdx) {\n    var point = data.getItemLayout(newIdx);\n\n    if (symbolNeedsDraw(data, point, newIdx, opt)) {\n      var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n      symbolEl.attr('position', point);\n      data.setItemGraphicEl(newIdx, symbolEl);\n      group.add(symbolEl);\n    }\n  }).update(function (newIdx, oldIdx) {\n    var symbolEl = oldData.getItemGraphicEl(oldIdx);\n    var point = data.getItemLayout(newIdx);\n\n    if (!symbolNeedsDraw(data, point, newIdx, opt)) {\n      group.remove(symbolEl);\n      return;\n    }\n\n    if (!symbolEl) {\n      symbolEl = new SymbolCtor(data, newIdx);\n      symbolEl.attr('position', point);\n    } else {\n      symbolEl.updateData(data, newIdx, seriesScope);\n      graphic.updateProps(symbolEl, {\n        position: point\n      }, seriesModel);\n    } // Add back\n\n\n    group.add(symbolEl);\n    data.setItemGraphicEl(newIdx, symbolEl);\n  }).remove(function (oldIdx) {\n    var el = oldData.getItemGraphicEl(oldIdx);\n    el && el.fadeOut(function () {\n      group.remove(el);\n    });\n  }).execute();\n  this._data = data;\n};\n\nsymbolDrawProto.isPersistent = function () {\n  return true;\n};\n\nsymbolDrawProto.updateLayout = function () {\n  var data = this._data;\n\n  if (data) {\n    // Not use animation\n    data.eachItemGraphicEl(function (el, idx) {\n      var point = data.getItemLayout(idx);\n      el.attr('position', point);\n    });\n  }\n};\n\nsymbolDrawProto.incrementalPrepareUpdate = function (data) {\n  this._seriesScope = makeSeriesScope(data);\n  this._data = null;\n  this.group.removeAll();\n};\n/**\n * Update symbols draw by new data\n * @param {module:echarts/data/List} data\n * @param {Object} [opt] Or isIgnore\n * @param {Function} [opt.isIgnore]\n * @param {Object} [opt.clipShape]\n */\n\n\nsymbolDrawProto.incrementalUpdate = function (taskParams, data, opt) {\n  opt = normalizeUpdateOpt(opt);\n\n  function updateIncrementalAndHover(el) {\n    if (!el.isGroup) {\n      el.incremental = el.useHoverLayer = true;\n    }\n  }\n\n  for (var idx = taskParams.start; idx < taskParams.end; idx++) {\n    var point = data.getItemLayout(idx);\n\n    if (symbolNeedsDraw(data, point, idx, opt)) {\n      var el = new this._symbolCtor(data, idx, this._seriesScope);\n      el.traverse(updateIncrementalAndHover);\n      el.attr('position', point);\n      this.group.add(el);\n      data.setItemGraphicEl(idx, el);\n    }\n  }\n};\n\nfunction normalizeUpdateOpt(opt) {\n  if (opt != null && !isObject(opt)) {\n    opt = {\n      isIgnore: opt\n    };\n  }\n\n  return opt || {};\n}\n\nsymbolDrawProto.remove = function (enableAnimation) {\n  var group = this.group;\n  var data = this._data; // Incremental model do not have this._data.\n\n  if (data && enableAnimation) {\n    data.eachItemGraphicEl(function (el) {\n      el.fadeOut(function () {\n        group.remove(el);\n      });\n    });\n  } else {\n    group.removeAll();\n  }\n};\n\nfunction makeSeriesScope(data) {\n  var seriesModel = data.hostModel;\n  return {\n    itemStyle: seriesModel.getModel('itemStyle').getItemStyle(['color']),\n    hoverItemStyle: seriesModel.getModel('emphasis.itemStyle').getItemStyle(),\n    symbolRotate: seriesModel.get('symbolRotate'),\n    symbolOffset: seriesModel.get('symbolOffset'),\n    hoverAnimation: seriesModel.get('hoverAnimation'),\n    labelModel: seriesModel.getModel('label'),\n    hoverLabelModel: seriesModel.getModel('emphasis.label'),\n    cursorStyle: seriesModel.get('cursor')\n  };\n}\n\nvar _default = SymbolDraw;\nmodule.exports = _default;","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('echarts/lib/echarts'), require('echarts/lib/component/tooltip'), require('echarts/lib/component/legend'), require('echarts/lib/chart/line')) :\n  typeof define === 'function' && define.amd ? define(['echarts/lib/echarts', 'echarts/lib/component/tooltip', 'echarts/lib/component/legend', 'echarts/lib/chart/line'], factory) :\n  (global.VeLine = factory(global.echarts));\n}(this, (function (echartsLib) { 'use strict';\n\n  echartsLib = echartsLib && echartsLib.hasOwnProperty('default') ? echartsLib['default'] : echartsLib;\n\n  var ABBR = {\n    th: 3,\n    mi: 6,\n    bi: 9,\n    tr: 12\n  };\n\n  var DEFAULT_OPTIONS = {\n    zeroFormat: null,\n    nullFormat: null,\n    defaultFormat: '0,0',\n    scalePercentBy100: true,\n    abbrLabel: {\n      th: 'k',\n      mi: 'm',\n      bi: 'b',\n      tr: 't'\n    }\n  };\n\n  var TRILLION = 1e12;\n  var BILLION = 1e9;\n  var MILLION = 1e6;\n  var THOUSAND = 1e3;\n\n  function numIsNaN(value) {\n    return typeof value === 'number' && isNaN(value);\n  }\n\n  function toFixed(value, maxDecimals, roundingFunction, optionals) {\n    var splitValue = value.toString().split('.');\n    var minDecimals = maxDecimals - (optionals || 0);\n    var boundedPrecision = splitValue.length === 2 ? Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals) : minDecimals;\n    var power = Math.pow(10, boundedPrecision);\n    var output = (roundingFunction(value + 'e+' + boundedPrecision) / power).toFixed(boundedPrecision);\n\n    if (optionals > maxDecimals - boundedPrecision) {\n      var optionalsRegExp = new RegExp('\\\\.?0{1,' + (optionals - (maxDecimals - boundedPrecision)) + '}$');\n      output = output.replace(optionalsRegExp, '');\n    }\n\n    return output;\n  }\n\n  function numberToFormat(options, value, format, roundingFunction) {\n    var abs = Math.abs(value);\n    var negP = false;\n    var optDec = false;\n    var abbr = '';\n    var decimal = '';\n    var neg = false;\n    var abbrForce = void 0;\n    var signed = void 0;\n    format = format || '';\n\n    value = value || 0;\n\n    if (~format.indexOf('(')) {\n      negP = true;\n      format = format.replace(/[(|)]/g, '');\n    } else if (~format.indexOf('+') || ~format.indexOf('-')) {\n      signed = ~format.indexOf('+') ? format.indexOf('+') : value < 0 ? format.indexOf('-') : -1;\n      format = format.replace(/[+|-]/g, '');\n    }\n    if (~format.indexOf('a')) {\n      abbrForce = format.match(/a(k|m|b|t)?/);\n\n      abbrForce = abbrForce ? abbrForce[1] : false;\n\n      if (~format.indexOf(' a')) abbr = ' ';\n      format = format.replace(new RegExp(abbr + 'a[kmbt]?'), '');\n\n      if (abs >= TRILLION && !abbrForce || abbrForce === 't') {\n        abbr += options.abbrLabel.tr;\n        value = value / TRILLION;\n      } else if (abs < TRILLION && abs >= BILLION && !abbrForce || abbrForce === 'b') {\n        abbr += options.abbrLabel.bi;\n        value = value / BILLION;\n      } else if (abs < BILLION && abs >= MILLION && !abbrForce || abbrForce === 'm') {\n        abbr += options.abbrLabel.mi;\n        value = value / MILLION;\n      } else if (abs < MILLION && abs >= THOUSAND && !abbrForce || abbrForce === 'k') {\n        abbr += options.abbrLabel.th;\n        value = value / THOUSAND;\n      }\n    }\n    if (~format.indexOf('[.]')) {\n      optDec = true;\n      format = format.replace('[.]', '.');\n    }\n    var int = value.toString().split('.')[0];\n    var precision = format.split('.')[1];\n    var thousands = format.indexOf(',');\n    var leadingCount = (format.split('.')[0].split(',')[0].match(/0/g) || []).length;\n\n    if (precision) {\n      if (~precision.indexOf('[')) {\n        precision = precision.replace(']', '');\n        precision = precision.split('[');\n        decimal = toFixed(value, precision[0].length + precision[1].length, roundingFunction, precision[1].length);\n      } else {\n        decimal = toFixed(value, precision.length, roundingFunction);\n      }\n\n      int = decimal.split('.')[0];\n      decimal = ~decimal.indexOf('.') ? '.' + decimal.split('.')[1] : '';\n      if (optDec && +decimal.slice(1) === 0) decimal = '';\n    } else {\n      int = toFixed(value, 0, roundingFunction);\n    }\n    if (abbr && !abbrForce && +int >= 1000 && abbr !== ABBR.trillion) {\n      int = '' + +int / 1000;\n      abbr = ABBR.million;\n    }\n    if (~int.indexOf('-')) {\n      int = int.slice(1);\n      neg = true;\n    }\n    if (int.length < leadingCount) {\n      for (var i = leadingCount - int.length; i > 0; i--) {\n        int = '0' + int;\n      }\n    }\n\n    if (thousands > -1) {\n      int = int.toString().replace(/(\\d)(?=(\\d{3})+(?!\\d))/g, '$1' + ',');\n    }\n\n    if (!format.indexOf('.')) int = '';\n\n    var output = int + decimal + (abbr || '');\n\n    if (negP) {\n      output = (negP && neg ? '(' : '') + output + (negP && neg ? ')' : '');\n    } else {\n      if (signed >= 0) {\n        output = signed === 0 ? (neg ? '-' : '+') + output : output + (neg ? '-' : '+');\n      } else if (neg) {\n        output = '-' + output;\n      }\n    }\n\n    return output;\n  }\n\n  function extend(target, sub) {\n    Object.keys(sub).forEach(function (key) {\n      target[key] = sub[key];\n    });\n  }\n\n  var numerifyPercent = {\n    regexp: /%/,\n    format: function format(value, formatType, roundingFunction, numerify) {\n      var space = ~formatType.indexOf(' %') ? ' ' : '';\n      var output = void 0;\n\n      if (numerify.options.scalePercentBy100) value = value * 100;\n\n      formatType = formatType.replace(/\\s?%/, '');\n\n      output = numerify._numberToFormat(value, formatType, roundingFunction);\n\n      if (~output.indexOf(')')) {\n        output = output.split('');\n        output.splice(-1, 0, space + '%');\n        output = output.join('');\n      } else {\n        output = output + space + '%';\n      }\n\n      return output;\n    }\n  };\n\n  var options = {};\n  var formats = {};\n\n  extend(options, DEFAULT_OPTIONS);\n\n  function format(value, formatType, roundingFunction) {\n    formatType = formatType || options.defaultFormat;\n    roundingFunction = roundingFunction || Math.round;\n    var output = void 0;\n    var formatFunction = void 0;\n\n    if (value === 0 && options.zeroFormat !== null) {\n      output = options.zeroFormat;\n    } else if (value === null && options.nullFormat !== null) {\n      output = options.nullFormat;\n    } else {\n      for (var kind in formats) {\n        if (formats[kind] && formatType.match(formats[kind].regexp)) {\n          formatFunction = formats[kind].format;\n          break;\n        }\n      }\n      formatFunction = formatFunction || numberToFormat.bind(null, options);\n      output = formatFunction(value, formatType, roundingFunction, numerify);\n    }\n\n    return output;\n  }\n\n  function numerify(input, formatType, roundingFunction) {\n    var value = void 0;\n\n    if (input === 0 || typeof input === 'undefined') {\n      value = 0;\n    } else if (input === null || numIsNaN(input)) {\n      value = null;\n    } else if (typeof input === 'string') {\n      if (options.zeroFormat && input === options.zeroFormat) {\n        value = 0;\n      } else if (options.nullFormat && input === options.nullFormat || !input.replace(/[^0-9]+/g, '').length) {\n        value = null;\n      } else {\n        value = +input;\n      }\n    } else {\n      value = +input || null;\n    }\n\n    return format(value, formatType, roundingFunction);\n  }\n\n  numerify.options = options;\n  numerify._numberToFormat = numberToFormat.bind(null, options);\n  numerify.register = function (name, format) {\n    formats[name] = format;\n  };\n  numerify.unregister = function (name) {\n    formats[name] = null;\n  };\n  numerify.setOptions = function (opts) {\n    extend(options, opts);\n  };\n  numerify.reset = function () {\n    extend(options, DEFAULT_OPTIONS);\n  };\n\n  numerify.register('percentage', numerifyPercent);\n\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  };\n\n  var _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  function debounce(fn, delay) {\n    var timer = null;\n    return function () {\n      var self = this;\n      var args = arguments;\n      clearTimeout(timer);\n      timer = setTimeout(function () {\n        fn.apply(self, args);\n      }, delay);\n    };\n  }\n\n  function set$1(target, path, value) {\n    if (!path) return;\n    var targetTemp = target;\n    var pathArr = path.split('.');\n    pathArr.forEach(function (item, index) {\n      if (index === pathArr.length - 1) {\n        targetTemp[item] = value;\n      } else {\n        if (!targetTemp[item]) targetTemp[item] = {};\n        targetTemp = targetTemp[item];\n      }\n    });\n  }\n\n  var _typeof$1 = typeof Symbol === \"function\" && _typeof(Symbol.iterator) === \"symbol\" ? function (obj) {\n    return typeof obj === 'undefined' ? 'undefined' : _typeof(obj);\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === 'undefined' ? 'undefined' : _typeof(obj);\n  };\n\n  function getType(v) {\n    return Object.prototype.toString.call(v);\n  }\n\n  function getTypeof(v) {\n    return typeof v === 'undefined' ? 'undefined' : _typeof$1(v);\n  }\n\n  function isObject(v) {\n    return getType(v) === '[object Object]';\n  }\n\n  function isArray(v) {\n    return getType(v) === '[object Array]';\n  }\n\n  function isFunction(v) {\n    return getType(v) === '[object Function]';\n  }\n\n  function cloneDeep(v) {\n    return JSON.parse(JSON.stringify(v));\n  }\n\n  function camelToKebab(s) {\n    return s.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n  }\n\n  function hasOwn(source, target) {\n    return Object.prototype.hasOwnProperty.call(source, target);\n  }\n\n  function isEqual(alice, bob) {\n    if (alice === bob) return true;\n    if (alice === null || bob === null || getTypeof(alice) !== 'object' || getTypeof(bob) !== 'object') {\n      return alice === bob;\n    }\n\n    for (var key in alice) {\n      if (!hasOwn(alice, key)) continue;\n      var aliceValue = alice[key];\n      var bobValue = bob[key];\n      var aliceType = getTypeof(aliceValue);\n\n      if (getTypeof(bobValue) === 'undefined') {\n        return false;\n      } else if (aliceType === 'object') {\n        if (!isEqual(aliceValue, bobValue)) return false;\n      } else if (aliceValue !== bobValue) {\n        return false;\n      }\n    }\n    for (var _key in bob) {\n      if (!hasOwn(bob, _key)) continue;\n      if (getTypeof(alice)[_key] === 'undefined') return false;\n    }\n\n    return true;\n  }\n\n  var getFormated = function getFormated(val, type, digit) {\n    var defaultVal = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '-';\n\n    if (isNaN(val)) return defaultVal;\n    if (!type) return val;\n    if (isFunction(type)) return type(val, numerify);\n\n    digit = isNaN(digit) ? 0 : ++digit;\n    var digitStr = '.[' + new Array(digit).join(0) + ']';\n    var formatter = type;\n    switch (type) {\n      case 'KMB':\n        formatter = digit ? '0,0' + digitStr + 'a' : '0,0a';\n        break;\n      case 'normal':\n        formatter = digit ? '0,0' + digitStr : '0,0';\n        break;\n      case 'percent':\n        formatter = digit ? '0,0' + digitStr + '%' : '0,0.[00]%';\n        break;\n    }\n    return numerify(val, formatter);\n  };\n\n  var getStackMap = function getStackMap(stack) {\n    var stackMap = {};\n    Object.keys(stack).forEach(function (item) {\n      stack[item].forEach(function (name) {\n        stackMap[name] = item;\n      });\n    });\n    return stackMap;\n  };\n\n  function getLineXAxis(args) {\n    var dimension = args.dimension,\n        rows = args.rows,\n        xAxisName = args.xAxisName,\n        axisVisible = args.axisVisible,\n        xAxisType = args.xAxisType;\n\n    return dimension.map(function (item, index) {\n      return {\n        type: xAxisType,\n        nameLocation: 'middle',\n        nameGap: 22,\n        name: xAxisName[index] || '',\n        axisTick: { show: true, lineStyle: { color: '#eee' } },\n        data: rows.map(function (row) {\n          return row[item];\n        }),\n        show: axisVisible\n      };\n    });\n  }\n\n  function getLineSeries(args) {\n    var rows = args.rows,\n        axisSite = args.axisSite,\n        metrics = args.metrics,\n        area = args.area,\n        stack = args.stack,\n        nullAddZero = args.nullAddZero,\n        labelMap = args.labelMap,\n        label = args.label,\n        itemStyle = args.itemStyle,\n        lineStyle = args.lineStyle,\n        areaStyle = args.areaStyle,\n        dimension = args.dimension;\n\n    var series = [];\n    var dataTemp = {};\n    var stackMap = stack && getStackMap(stack);\n    metrics.forEach(function (item) {\n      dataTemp[item] = [];\n    });\n    rows.forEach(function (row) {\n      metrics.forEach(function (item) {\n        var value = null;\n        if (row[item] != null) {\n          value = row[item];\n        } else if (nullAddZero) {\n          value = 0;\n        }\n        dataTemp[item].push([row[dimension[0]], value]);\n      });\n    });\n    metrics.forEach(function (item) {\n      var seriesItem = {\n        name: labelMap[item] != null ? labelMap[item] : item,\n        type: 'line',\n        data: dataTemp[item]\n      };\n\n      if (area) seriesItem.areaStyle = { normal: {} };\n      if (axisSite.right) {\n        seriesItem.yAxisIndex = ~axisSite.right.indexOf(item) ? 1 : 0;\n      }\n\n      if (stack && stackMap[item]) seriesItem.stack = stackMap[item];\n\n      if (label) seriesItem.label = label;\n      if (itemStyle) seriesItem.itemStyle = itemStyle;\n      if (lineStyle) seriesItem.lineStyle = lineStyle;\n      if (areaStyle) seriesItem.areaStyle = areaStyle;\n\n      series.push(seriesItem);\n    });\n    return series;\n  }\n\n  function getLineYAxis(args) {\n    var yAxisName = args.yAxisName,\n        yAxisType = args.yAxisType,\n        axisVisible = args.axisVisible,\n        scale = args.scale,\n        min = args.min,\n        max = args.max,\n        digit = args.digit;\n\n    var yAxisBase = {\n      type: 'value',\n      axisTick: {\n        show: false\n      },\n      show: axisVisible\n    };\n    var yAxis = [];\n\n    var _loop = function _loop(i) {\n      if (yAxisType[i]) {\n        yAxis[i] = _extends({}, yAxisBase, {\n          axisLabel: {\n            formatter: function formatter(val) {\n              return getFormated(val, yAxisType[i], digit);\n            }\n          }\n        });\n      } else {\n        yAxis[i] = _extends({}, yAxisBase);\n      }\n      yAxis[i].name = yAxisName[i] || '';\n      yAxis[i].scale = scale[i] || false;\n      yAxis[i].min = min[i] || null;\n      yAxis[i].max = max[i] || null;\n    };\n\n    for (var i = 0; i < 2; i++) {\n      _loop(i);\n    }\n    return yAxis;\n  }\n\n  function getLineTooltip(args) {\n    var axisSite = args.axisSite,\n        yAxisType = args.yAxisType,\n        digit = args.digit,\n        labelMap = args.labelMap,\n        tooltipFormatter = args.tooltipFormatter;\n\n    var rightItems = axisSite.right || [];\n    var rightList = labelMap ? rightItems.map(function (item) {\n      return labelMap[item] === undefined ? item : labelMap[item];\n    }) : rightItems;\n    return {\n      trigger: 'axis',\n      formatter: function formatter(items) {\n        if (tooltipFormatter) {\n          return tooltipFormatter.apply(null, arguments);\n        }\n        var tpl = [];\n        var _items$ = items[0],\n            name = _items$.name,\n            axisValueLabel = _items$.axisValueLabel;\n\n        var title = name || axisValueLabel;\n        tpl.push(title + '<br>');\n        items.forEach(function (_ref) {\n          var seriesName = _ref.seriesName,\n              data = _ref.data,\n              marker = _ref.marker;\n\n          var showData = null;\n          var type = ~rightList.indexOf(seriesName) ? yAxisType[1] : yAxisType[0];\n          var itemData = isArray(data) ? data[1] : data;\n          showData = getFormated(itemData, type, digit);\n          tpl.push(marker);\n          tpl.push(seriesName + ': ' + showData);\n          tpl.push('<br>');\n        });\n        return tpl.join('');\n      }\n    };\n  }\n\n  function getLegend(args) {\n    var metrics = args.metrics,\n        legendName = args.legendName,\n        labelMap = args.labelMap;\n\n    if (!legendName && !labelMap) return { data: metrics };\n    var data = labelMap ? metrics.map(function (item) {\n      return labelMap[item] == null ? item : labelMap[item];\n    }) : metrics;\n    return {\n      data: data,\n      formatter: function formatter(name) {\n        return legendName[name] != null ? legendName[name] : name;\n      }\n    };\n  }\n\n  var line$1 = function line$$1(columns, rows, settings, extra) {\n    rows = isArray(rows) ? rows : [];\n    columns = isArray(columns) ? columns : [];\n    var _settings$axisSite = settings.axisSite,\n        axisSite = _settings$axisSite === undefined ? {} : _settings$axisSite,\n        _settings$yAxisType = settings.yAxisType,\n        yAxisType = _settings$yAxisType === undefined ? ['normal', 'normal'] : _settings$yAxisType,\n        _settings$xAxisType = settings.xAxisType,\n        xAxisType = _settings$xAxisType === undefined ? 'category' : _settings$xAxisType,\n        _settings$yAxisName = settings.yAxisName,\n        yAxisName = _settings$yAxisName === undefined ? [] : _settings$yAxisName,\n        _settings$dimension = settings.dimension,\n        dimension = _settings$dimension === undefined ? [columns[0]] : _settings$dimension,\n        _settings$xAxisName = settings.xAxisName,\n        xAxisName = _settings$xAxisName === undefined ? [] : _settings$xAxisName,\n        _settings$axisVisible = settings.axisVisible,\n        axisVisible = _settings$axisVisible === undefined ? true : _settings$axisVisible,\n        area = settings.area,\n        stack = settings.stack,\n        _settings$scale = settings.scale,\n        scale = _settings$scale === undefined ? [false, false] : _settings$scale,\n        _settings$min = settings.min,\n        min = _settings$min === undefined ? [null, null] : _settings$min,\n        _settings$max = settings.max,\n        max = _settings$max === undefined ? [null, null] : _settings$max,\n        _settings$nullAddZero = settings.nullAddZero,\n        nullAddZero = _settings$nullAddZero === undefined ? false : _settings$nullAddZero,\n        _settings$digit = settings.digit,\n        digit = _settings$digit === undefined ? 2 : _settings$digit,\n        _settings$legendName = settings.legendName,\n        legendName = _settings$legendName === undefined ? {} : _settings$legendName,\n        _settings$labelMap = settings.labelMap,\n        labelMap = _settings$labelMap === undefined ? {} : _settings$labelMap,\n        label = settings.label,\n        itemStyle = settings.itemStyle,\n        lineStyle = settings.lineStyle,\n        areaStyle = settings.areaStyle;\n    var tooltipVisible = extra.tooltipVisible,\n        legendVisible = extra.legendVisible,\n        tooltipFormatter = extra.tooltipFormatter;\n\n    var metrics = columns.slice();\n\n    if (axisSite.left && axisSite.right) {\n      metrics = axisSite.left.concat(axisSite.right);\n    } else if (axisSite.left && !axisSite.right) {\n      metrics = axisSite.left;\n    } else if (settings.metrics) {\n      metrics = settings.metrics;\n    } else {\n      metrics.splice(columns.indexOf(dimension[0]), 1);\n    }\n\n    var legend$$1 = legendVisible && getLegend({ metrics: metrics, legendName: legendName, labelMap: labelMap });\n    var tooltip$$1 = tooltipVisible && getLineTooltip({\n      axisSite: axisSite,\n      yAxisType: yAxisType,\n      digit: digit,\n      labelMap: labelMap,\n      xAxisType: xAxisType,\n      tooltipFormatter: tooltipFormatter\n    });\n    var xAxis = getLineXAxis({\n      dimension: dimension,\n      rows: rows,\n      xAxisName: xAxisName,\n      axisVisible: axisVisible,\n      xAxisType: xAxisType\n    });\n    var yAxis = getLineYAxis({\n      yAxisName: yAxisName,\n      yAxisType: yAxisType,\n      axisVisible: axisVisible,\n      scale: scale,\n      min: min,\n      max: max,\n      digit: digit\n    });\n    var series = getLineSeries({\n      rows: rows,\n      axisSite: axisSite,\n      metrics: metrics,\n      area: area,\n      stack: stack,\n      nullAddZero: nullAddZero,\n      labelMap: labelMap,\n      label: label,\n      itemStyle: itemStyle,\n      lineStyle: lineStyle,\n      areaStyle: areaStyle,\n      xAxisType: xAxisType,\n      dimension: dimension\n    });\n    var options = { legend: legend$$1, xAxis: xAxis, series: series, yAxis: yAxis, tooltip: tooltip$$1 };\n    return options;\n  };\n\n  var Loading = { render: function render() {\n      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: \"v-charts-component-loading\" }, [_c('div', { staticClass: \"loader\" }, [_c('div', { staticClass: \"loading-spinner\" }, [_c('svg', { staticClass: \"circular\", attrs: { \"viewBox\": \"25 25 50 50\" } }, [_c('circle', { staticClass: \"path\", attrs: { \"cx\": \"50\", \"cy\": \"50\", \"r\": \"20\", \"fill\": \"none\" } })])])])]);\n    }, staticRenderFns: []\n  };\n\n  var DataEmpty = { render: function render() {\n      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: \"v-charts-data-empty\" }, [_vm._v(\"  \")]);\n    }, staticRenderFns: []\n  };\n\n  var DEFAULT_THEME = {\n    categoryAxis: {\n      axisLine: { show: false },\n      axisTick: { show: false },\n      splitLine: { show: false }\n    },\n    valueAxis: {\n      axisLine: { show: false }\n    },\n    line: {\n      smooth: true\n    },\n    grid: {\n      containLabel: true,\n      left: 10,\n      right: 10\n    }\n  };\n\n  var DEFAULT_COLORS = ['#19d4ae', '#5ab1ef', '#fa6e86', '#ffb980', '#0067a6', '#c4b4e4', '#d87a80', '#9cbbff', '#d9d0c7', '#87a997', '#d49ea2', '#5b4947', '#7ba3a8'];\n\n  var STATIC_PROPS = ['initOptions', 'loading', 'dataEmpty', 'judgeWidth', 'widthChangeDelay'];\n\n  var ECHARTS_SETTINGS = ['grid', 'dataZoom', 'visualMap', 'toolbox', 'title', 'legend', 'xAxis', 'yAxis', 'radar', 'tooltip', 'axisPointer', 'brush', 'geo', 'timeline', 'graphic', 'series', 'backgroundColor', 'textStyle'];\n\n  function setExtend (options, extend) {\n    Object.keys(extend).forEach(function (attr) {\n      var value = extend[attr];\n      if (~attr.indexOf('.')) {\n        // eg: a.b.c a.1.b\n        set$1(options, attr, value);\n      } else if (typeof value === 'function') {\n        // get callback value\n        options[attr] = value(options[attr]);\n      } else {\n        // mixin extend value\n        if (isArray(options[attr]) && isObject(options[attr][0])) {\n          // eg: [{ xx: 1 }, { xx: 2 }]\n          options[attr].forEach(function (option, index) {\n            options[attr][index] = _extends({}, option, value);\n          });\n        } else if (isObject(options[attr])) {\n          // eg: { xx: 1, yy: 2 }\n          options[attr] = _extends({}, options[attr], value);\n        } else {\n          options[attr] = value;\n        }\n      }\n    });\n  }\n\n  function setMark (seriesItem, marks) {\n    Object.keys(marks).forEach(function (key) {\n      if (marks[key]) seriesItem[key] = marks[key];\n    });\n  }\n\n  function setAnimation (options, animation) {\n    Object.keys(animation).forEach(function (key) {\n      options[key] = animation[key];\n    });\n  }\n\n  var Core = {\n    render: function render(h) {\n      return h('div', {\n        class: [camelToKebab(this.$options.name || this.$options._componentTag)],\n        style: this.canvasStyle\n      }, [h('div', {\n        style: this.canvasStyle,\n        class: { 'v-charts-mask-status': this.dataEmpty || this.loading },\n        ref: 'canvas'\n      }), h(DataEmpty, {\n        style: { display: this.dataEmpty ? '' : 'none' }\n      }), h(Loading, {\n        style: { display: this.loading ? '' : 'none' }\n      }), this.$slots.default]);\n    },\n\n\n    props: {\n      data: { type: [Object, Array], default: function _default() {\n          return {};\n        }\n      },\n      settings: { type: Object, default: function _default() {\n          return {};\n        }\n      },\n      width: { type: String, default: 'auto' },\n      height: { type: String, default: '400px' },\n      beforeConfig: { type: Function },\n      afterConfig: { type: Function },\n      afterSetOption: { type: Function },\n      afterSetOptionOnce: { type: Function },\n      events: { type: Object },\n      grid: { type: [Object, Array] },\n      colors: { type: Array },\n      tooltipVisible: { type: Boolean, default: true },\n      legendVisible: { type: Boolean, default: true },\n      legendPosition: { type: String },\n      markLine: { type: Object },\n      markArea: { type: Object },\n      markPoint: { type: Object },\n      visualMap: { type: [Object, Array] },\n      dataZoom: { type: [Object, Array] },\n      toolbox: { type: [Object, Array] },\n      initOptions: { type: Object, default: function _default() {\n          return {};\n        }\n      },\n      title: [Object, Array],\n      legend: [Object, Array],\n      xAxis: [Object, Array],\n      yAxis: [Object, Array],\n      radar: Object,\n      tooltip: Object,\n      axisPointer: [Object, Array],\n      brush: [Object, Array],\n      geo: [Object, Array],\n      timeline: [Object, Array],\n      graphic: [Object, Array],\n      series: [Object, Array],\n      backgroundColor: [Object, String],\n      textStyle: [Object, Array],\n      animation: Object,\n      theme: Object,\n      themeName: String,\n      loading: Boolean,\n      dataEmpty: Boolean,\n      extend: Object,\n      judgeWidth: { type: Boolean, default: false },\n      widthChangeDelay: { type: Number, default: 300 },\n      tooltipFormatter: { type: Function },\n      resizeable: { type: Boolean, default: true },\n      resizeDelay: { type: Number, default: 200 },\n      changeDelay: { type: Number, default: 0 },\n      setOptionOpts: { type: [Boolean, Object], default: true },\n      cancelResizeCheck: Boolean,\n      notSetUnchange: Array,\n      log: Boolean\n    },\n\n    watch: {\n      data: {\n        deep: true,\n        handler: function handler(v) {\n          if (v) {\n            this.changeHandler();\n          }\n        }\n      },\n\n      settings: {\n        deep: true,\n        handler: function handler(v) {\n          if (v.type && this.chartLib) this.chartHandler = this.chartLib[v.type];\n          this.changeHandler();\n        }\n      },\n\n      width: 'nextTickResize',\n      height: 'nextTickResize',\n\n      events: {\n        deep: true,\n        handler: 'createEventProxy'\n      },\n\n      theme: {\n        deep: true,\n        handler: 'themeChange'\n      },\n\n      themeName: 'themeChange',\n\n      resizeable: 'resizeableHandler'\n    },\n\n    computed: {\n      canvasStyle: function canvasStyle() {\n        return {\n          width: this.width,\n          height: this.height,\n          position: 'relative'\n        };\n      },\n      chartColor: function chartColor() {\n        return this.colors || this.theme && this.theme.color || DEFAULT_COLORS;\n      }\n    },\n\n    methods: {\n      dataHandler: function dataHandler() {\n        if (!this.chartHandler) return;\n        var data = this.data;\n        var _data = data,\n            _data$columns = _data.columns,\n            columns = _data$columns === undefined ? [] : _data$columns,\n            _data$rows = _data.rows,\n            rows = _data$rows === undefined ? [] : _data$rows;\n\n        var extra = {\n          tooltipVisible: this.tooltipVisible,\n          legendVisible: this.legendVisible,\n          echarts: this.echarts,\n          color: this.chartColor,\n          tooltipFormatter: this.tooltipFormatter,\n          _once: this._once\n        };\n        if (this.beforeConfig) data = this.beforeConfig(data);\n\n        var options = this.chartHandler(columns, rows, this.settings, extra);\n        if (options) {\n          if (typeof options.then === 'function') {\n            options.then(this.optionsHandler);\n          } else {\n            this.optionsHandler(options);\n          }\n        }\n      },\n      nextTickResize: function nextTickResize() {\n        this.$nextTick(this.resize);\n      },\n      resize: function resize() {\n        if (!this.cancelResizeCheck) {\n          if (this.$el && this.$el.clientWidth && this.$el.clientHeight) {\n            this.echartsResize();\n          }\n        } else {\n          this.echartsResize();\n        }\n      },\n      echartsResize: function echartsResize() {\n        this.echarts && this.echarts.resize();\n      },\n      optionsHandler: function optionsHandler(options) {\n        var _this = this;\n\n        // legend\n        if (this.legendPosition && options.legend) {\n          options.legend[this.legendPosition] = 10;\n          if (~['left', 'right'].indexOf(this.legendPosition)) {\n            options.legend.top = 'middle';\n            options.legend.orient = 'vertical';\n          }\n        }\n        // color\n        options.color = this.chartColor;\n        // echarts self settings\n        ECHARTS_SETTINGS.forEach(function (setting) {\n          if (_this[setting]) options[setting] = _this[setting];\n        });\n        // animation\n        if (this.animation) setAnimation(options, this.animation);\n        // marks\n        if (this.markArea || this.markLine || this.markPoint) {\n          var marks = {\n            markArea: this.markArea,\n            markLine: this.markLine,\n            markPoint: this.markPoint\n          };\n          var series = options.series;\n          if (isArray(series)) {\n            series.forEach(function (item) {\n              setMark(item, marks);\n            });\n          } else if (isObject(series)) {\n            setMark(series, marks);\n          }\n        }\n        // change inited echarts settings\n        if (this.extend) setExtend(options, this.extend);\n        if (this.afterConfig) options = this.afterConfig(options);\n        var setOptionOpts = this.setOptionOpts;\n        // map chart not merge\n        if ((this.settings.bmap || this.settings.amap) && !isObject(setOptionOpts)) {\n          setOptionOpts = false;\n        }\n        // exclude unchange options\n        if (this.notSetUnchange && this.notSetUnchange.length) {\n          this.notSetUnchange.forEach(function (item) {\n            var value = options[item];\n            if (value) {\n              if (isEqual(value, _this._store[item])) {\n                options[item] = undefined;\n              } else {\n                _this._store[item] = cloneDeep(value);\n              }\n            }\n          });\n          if (isObject(setOptionOpts)) {\n            setOptionOpts.notMerge = false;\n          } else {\n            setOptionOpts = false;\n          }\n        }\n        if (this._isDestroyed) return;\n        if (this.log) console.log(options);\n        this.echarts.setOption(options, setOptionOpts);\n        this.$emit('ready', this.echarts, options, echartsLib);\n        if (!this._once['ready-once']) {\n          this._once['ready-once'] = true;\n          this.$emit('ready-once', this.echarts, options, echartsLib);\n        }\n        if (this.judgeWidth) this.judgeWidthHandler(options);\n        if (this.afterSetOption) this.afterSetOption(this.echarts, options, echartsLib);\n        if (this.afterSetOptionOnce && !this._once['afterSetOptionOnce']) {\n          this._once['afterSetOptionOnce'] = true;\n          this.afterSetOptionOnce(this.echarts, options, echartsLib);\n        }\n      },\n      judgeWidthHandler: function judgeWidthHandler(options) {\n        var _this2 = this;\n\n        var widthChangeDelay = this.widthChangeDelay,\n            resize = this.resize;\n\n        if (this.$el.clientWidth || this.$el.clientHeight) {\n          resize();\n        } else {\n          this.$nextTick(function (_) {\n            if (_this2.$el.clientWidth || _this2.$el.clientHeight) {\n              resize();\n            } else {\n              setTimeout(function (_) {\n                resize();\n                if (!_this2.$el.clientWidth || !_this2.$el.clientHeight) {\n                  console.warn(' Can\\'t get dom width or height ');\n                }\n              }, widthChangeDelay);\n            }\n          });\n        }\n      },\n      resizeableHandler: function resizeableHandler(resizeable) {\n        if (resizeable && !this._once.onresize) this.addResizeListener();\n        if (!resizeable && this._once.onresize) this.removeResizeListener();\n      },\n      init: function init() {\n        if (this.echarts) return;\n        var themeName = this.themeName || this.theme || DEFAULT_THEME;\n        this.echarts = echartsLib.init(this.$refs.canvas, themeName, this.initOptions);\n        if (this.data) this.changeHandler();\n        this.createEventProxy();\n        if (this.resizeable) this.addResizeListener();\n      },\n      addResizeListener: function addResizeListener() {\n        window.addEventListener('resize', this.resizeHandler);\n        this._once.onresize = true;\n      },\n      removeResizeListener: function removeResizeListener() {\n        window.removeEventListener('resize', this.resizeHandler);\n        this._once.onresize = false;\n      },\n      addWatchToProps: function addWatchToProps() {\n        var _this3 = this;\n\n        var watchedVariable = this._watchers.map(function (watcher) {\n          return watcher.expression;\n        });\n        Object.keys(this.$props).forEach(function (prop) {\n          if (!~watchedVariable.indexOf(prop) && !~STATIC_PROPS.indexOf(prop)) {\n            var opts = {};\n            if (~['[object Object]', '[object Array]'].indexOf(getType(_this3.$props[prop]))) {\n              opts.deep = true;\n            }\n            _this3.$watch(prop, function () {\n              _this3.changeHandler();\n            }, opts);\n          }\n        });\n      },\n      createEventProxy: function createEventProxy() {\n        var _this4 = this;\n\n        //  on \n        //  events \n        //  events \n        var self = this;\n        var keys = Object.keys(this.events || {});\n        keys.length && keys.forEach(function (ev) {\n          if (_this4.registeredEvents.indexOf(ev) === -1) {\n            _this4.registeredEvents.push(ev);\n            _this4.echarts.on(ev, function (ev) {\n              return function () {\n                if (ev in self.events) {\n                  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n                    args[_key] = arguments[_key];\n                  }\n\n                  self.events[ev].apply(null, args);\n                }\n              };\n            }(ev));\n          }\n        });\n      },\n      themeChange: function themeChange(theme) {\n        this.clean();\n        this.echarts = null;\n        this.init();\n      },\n      clean: function clean() {\n        if (this.resizeable) this.removeResizeListener();\n        this.echarts.dispose();\n      }\n    },\n\n    created: function created() {\n      this.echarts = null;\n      this.registeredEvents = [];\n      this._once = {};\n      this._store = {};\n      this.resizeHandler = debounce(this.resize, this.resizeDelay);\n      this.changeHandler = debounce(this.dataHandler, this.changeDelay);\n      this.addWatchToProps();\n    },\n    mounted: function mounted() {\n      this.init();\n    },\n    beforeDestroy: function beforeDestroy() {\n      this.clean();\n    },\n\n\n    _numerify: numerify\n  };\n\n  var index = _extends({}, Core, {\n    name: 'VeLine',\n    data: function data() {\n      this.chartHandler = line$1;\n      return {};\n    }\n  });\n\n  return index;\n\n})));\n","var Path = require(\"zrender/lib/graphic/Path\");\n\nvar vec2 = require(\"zrender/lib/core/vector\");\n\nvar fixClipWithShadow = require(\"zrender/lib/graphic/helper/fixClipWithShadow\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Poly path support NaN point\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  // if (smoothMonotone == null) {\n  //     if (isMono(points, 'x')) {\n  //         return drawMono(ctx, points, start, segLen, allLen,\n  //             dir, smoothMin, smoothMax, smooth, 'x', connectNulls);\n  //     }\n  //     else if (isMono(points, 'y')) {\n  //         return drawMono(ctx, points, start, segLen, allLen,\n  //             dir, smoothMin, smoothMax, smooth, 'y', connectNulls);\n  //     }\n  //     else {\n  //         return drawNonMono.apply(this, arguments);\n  //     }\n  // }\n  // else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {\n  //     return drawMono.apply(this, arguments);\n  // }\n  // else {\n  //     return drawNonMono.apply(this, arguments);\n  // }\n  if (smoothMonotone === 'none' || !smoothMonotone) {\n    return drawNonMono.apply(this, arguments);\n  } else {\n    return drawMono.apply(this, arguments);\n  }\n}\n/**\n * Check if points is in monotone.\n *\n * @param {number[][]} points         Array of points which is in [x, y] form\n * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which\n *                                    dimension that is checking.\n *                                    If is 'none', `drawNonMono` should be\n *                                    called.\n *                                    If is undefined, either being monotone\n *                                    in 'x' or 'y' will call `drawMono`.\n */\n// function isMono(points, smoothMonotone) {\n//     if (points.length <= 1) {\n//         return true;\n//     }\n//     var dim = smoothMonotone === 'x' ? 0 : 1;\n//     var last = points[0][dim];\n//     var lastDiff = 0;\n//     for (var i = 1; i < points.length; ++i) {\n//         var diff = points[i][dim] - last;\n//         if (!isNaN(diff) && !isNaN(lastDiff)\n//             && diff !== 0 && lastDiff !== 0\n//             && ((diff >= 0) !== (lastDiff >= 0))\n//         ) {\n//             return false;\n//         }\n//         if (!isNaN(diff) && diff !== 0) {\n//             lastDiff = diff;\n//             last = points[i][dim];\n//         }\n//     }\n//     return true;\n// }\n\n/**\n * Draw smoothed line in monotone, in which only vertical or horizontal bezier\n * control points will be used. This should be used when points are monotone\n * either in x or y dimension.\n */\n\n\nfunction drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n    } else {\n      if (smooth > 0) {\n        var prevP = points[prevIdx];\n        var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both\n\n        var ctrlLen = (p[dim] - prevP[dim]) * smooth;\n        v2Copy(cp0, prevP);\n        cp0[dim] = prevP[dim] + ctrlLen;\n        v2Copy(cp1, p);\n        cp1[dim] = p[dim] - ctrlLen;\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\n\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar SymbolDraw = require(\"../helper/SymbolDraw\");\n\nvar SymbolClz = require(\"../helper/Symbol\");\n\nvar lineAnimationDiff = require(\"./lineAnimationDiff\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar modelUtil = require(\"../../util/model\");\n\nvar _poly = require(\"./poly\");\n\nvar Polyline = _poly.Polyline;\nvar Polygon = _poly.Polygon;\n\nvar ChartView = require(\"../../view/Chart\");\n\nvar _number = require(\"../../util/number\");\n\nvar round = _number.round;\n\nvar _helper = require(\"./helper\");\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// FIXME step not support polar\nfunction isPointsSame(points1, points2) {\n  if (points1.length !== points2.length) {\n    return;\n  }\n\n  for (var i = 0; i < points1.length; i++) {\n    var p1 = points1[i];\n    var p2 = points2[i];\n\n    if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n      return;\n    }\n  }\n\n  return true;\n}\n\nfunction getSmooth(smooth) {\n  return typeof smooth === 'number' ? smooth : smooth ? 0.5 : 0;\n}\n\nfunction getAxisExtentWithGap(axis) {\n  var extent = axis.getGlobalExtent();\n\n  if (axis.onBand) {\n    // Remove extra 1px to avoid line miter in clipped edge\n    var halfBandWidth = axis.getBandWidth() / 2 - 1;\n    var dir = extent[1] > extent[0] ? 1 : -1;\n    extent[0] += dir * halfBandWidth;\n    extent[1] -= dir * halfBandWidth;\n  }\n\n  return extent;\n}\n/**\n * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n * @param {module:echarts/data/List} data\n * @param {Object} dataCoordInfo\n * @param {Array.<Array.<number>>} points\n */\n\n\nfunction getStackedOnPoints(coordSys, data, dataCoordInfo) {\n  if (!dataCoordInfo.valueDim) {\n    return [];\n  }\n\n  var points = [];\n\n  for (var idx = 0, len = data.count(); idx < len; idx++) {\n    points.push(getStackedOnPoint(dataCoordInfo, coordSys, data, idx));\n  }\n\n  return points;\n}\n\nfunction createGridClipShape(cartesian, hasAnimation, forSymbol, seriesModel) {\n  var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n  var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n  var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n  var x = Math.min(xExtent[0], xExtent[1]);\n  var y = Math.min(yExtent[0], yExtent[1]);\n  var width = Math.max(xExtent[0], xExtent[1]) - x;\n  var height = Math.max(yExtent[0], yExtent[1]) - y; // Avoid float number rounding error for symbol on the edge of axis extent.\n  // See #7913 and `test/dataZoom-clip.html`.\n\n  if (forSymbol) {\n    x -= 0.5;\n    width += 0.5;\n    y -= 0.5;\n    height += 0.5;\n  } else {\n    var lineWidth = seriesModel.get('lineStyle.width') || 2; // Expand clip shape to avoid clipping when line value exceeds axis\n\n    var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n\n    if (isHorizontal) {\n      y -= expandSize;\n      height += expandSize * 2;\n    } else {\n      x -= expandSize;\n      width += expandSize * 2;\n    }\n  }\n\n  var clipPath = new graphic.Rect({\n    shape: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n    graphic.initProps(clipPath, {\n      shape: {\n        width: width,\n        height: height\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createPolarClipShape(polar, hasAnimation, forSymbol, seriesModel) {\n  var angleAxis = polar.getAngleAxis();\n  var radiusAxis = polar.getRadiusAxis();\n  var radiusExtent = radiusAxis.getExtent().slice();\n  radiusExtent[0] > radiusExtent[1] && radiusExtent.reverse();\n  var angleExtent = angleAxis.getExtent();\n  var RADIAN = Math.PI / 180; // Avoid float number rounding error for symbol on the edge of axis extent.\n\n  if (forSymbol) {\n    radiusExtent[0] -= 0.5;\n    radiusExtent[1] += 0.5;\n  }\n\n  var clipPath = new graphic.Sector({\n    shape: {\n      cx: round(polar.cx, 1),\n      cy: round(polar.cy, 1),\n      r0: round(radiusExtent[0], 1),\n      r: round(radiusExtent[1], 1),\n      startAngle: -angleExtent[0] * RADIAN,\n      endAngle: -angleExtent[1] * RADIAN,\n      clockwise: angleAxis.inverse\n    }\n  });\n\n  if (hasAnimation) {\n    clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: -angleExtent[1] * RADIAN\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nfunction createClipShape(coordSys, hasAnimation, forSymbol, seriesModel) {\n  return coordSys.type === 'polar' ? createPolarClipShape(coordSys, hasAnimation, forSymbol, seriesModel) : createGridClipShape(coordSys, hasAnimation, forSymbol, seriesModel);\n}\n\nfunction turnPointsIntoStep(points, coordSys, stepTurnAt) {\n  var baseAxis = coordSys.getBaseAxis();\n  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n  var stepPoints = [];\n\n  for (var i = 0; i < points.length - 1; i++) {\n    var nextPt = points[i + 1];\n    var pt = points[i];\n    stepPoints.push(pt);\n    var stepPt = [];\n\n    switch (stepTurnAt) {\n      case 'end':\n        stepPt[baseIndex] = nextPt[baseIndex];\n        stepPt[1 - baseIndex] = pt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n        break;\n\n      case 'middle':\n        // default is start\n        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n        var stepPt2 = [];\n        stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n        stepPt[1 - baseIndex] = pt[1 - baseIndex];\n        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n        stepPoints.push(stepPt);\n        stepPoints.push(stepPt2);\n        break;\n\n      default:\n        stepPt[baseIndex] = pt[baseIndex];\n        stepPt[1 - baseIndex] = nextPt[1 - baseIndex]; // default is start\n\n        stepPoints.push(stepPt);\n    }\n  } // Last points\n\n\n  points[i] && stepPoints.push(points[i]);\n  return stepPoints;\n}\n\nfunction getVisualGradient(data, coordSys) {\n  var visualMetaList = data.getVisual('visualMeta');\n\n  if (!visualMetaList || !visualMetaList.length || !data.count()) {\n    // When data.count() is 0, gradient range can not be calculated.\n    return;\n  }\n\n  if (coordSys.type !== 'cartesian2d') {\n    return;\n  }\n\n  var coordDim;\n  var visualMeta;\n\n  for (var i = visualMetaList.length - 1; i >= 0; i--) {\n    var dimIndex = visualMetaList[i].dimension;\n    var dimName = data.dimensions[dimIndex];\n    var dimInfo = data.getDimensionInfo(dimName);\n    coordDim = dimInfo && dimInfo.coordDim; // Can only be x or y\n\n    if (coordDim === 'x' || coordDim === 'y') {\n      visualMeta = visualMetaList[i];\n      break;\n    }\n  }\n\n  if (!visualMeta) {\n    return;\n  } // If the area to be rendered is bigger than area defined by LinearGradient,\n  // the canvas spec prescribes that the color of the first stop and the last\n  // stop should be used. But if two stops are added at offset 0, in effect\n  // browsers use the color of the second stop to render area outside\n  // LinearGradient. So we can only infinitesimally extend area defined in\n  // LinearGradient to render `outerColors`.\n\n\n  var axis = coordSys.getAxis(coordDim); // dataToCoor mapping may not be linear, but must be monotonic.\n\n  var colorStops = zrUtil.map(visualMeta.stops, function (stop) {\n    return {\n      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),\n      color: stop.color\n    };\n  });\n  var stopLen = colorStops.length;\n  var outerColors = visualMeta.outerColors.slice();\n\n  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {\n    colorStops.reverse();\n    outerColors.reverse();\n  }\n\n  var tinyExtent = 10; // Arbitrary value: 10px\n\n  var minCoord = colorStops[0].coord - tinyExtent;\n  var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;\n  var coordSpan = maxCoord - minCoord;\n\n  if (coordSpan < 1e-3) {\n    return 'transparent';\n  }\n\n  zrUtil.each(colorStops, function (stop) {\n    stop.offset = (stop.coord - minCoord) / coordSpan;\n  });\n  colorStops.push({\n    offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,\n    color: outerColors[1] || 'transparent'\n  });\n  colorStops.unshift({\n    // notice colorStops.length have been changed.\n    offset: stopLen ? colorStops[0].offset : 0.5,\n    color: outerColors[0] || 'transparent'\n  }); // zrUtil.each(colorStops, function (colorStop) {\n  //     // Make sure each offset has rounded px to avoid not sharp edge\n  //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n  // });\n\n  var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);\n  gradient[coordDim] = minCoord;\n  gradient[coordDim + '2'] = maxCoord;\n  return gradient;\n}\n\nfunction getIsIgnoreFunc(seriesModel, data, coordSys) {\n  var showAllSymbol = seriesModel.get('showAllSymbol');\n  var isAuto = showAllSymbol === 'auto';\n\n  if (showAllSymbol && !isAuto) {\n    return;\n  }\n\n  var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n\n  if (!categoryAxis) {\n    return;\n  } // Note that category label interval strategy might bring some weird effect\n  // in some scenario: users may wonder why some of the symbols are not\n  // displayed. So we show all symbols as possible as we can.\n\n\n  if (isAuto // Simplify the logic, do not determine label overlap here.\n  && canShowAllSymbolForCategory(categoryAxis, data)) {\n    return;\n  } // Otherwise follow the label interval strategy on category axis.\n\n\n  var categoryDataDim = data.mapDimension(categoryAxis.dim);\n  var labelMap = {};\n  zrUtil.each(categoryAxis.getViewLabels(), function (labelItem) {\n    labelMap[labelItem.tickValue] = 1;\n  });\n  return function (dataIndex) {\n    return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));\n  };\n}\n\nfunction canShowAllSymbolForCategory(categoryAxis, data) {\n  // In mose cases, line is monotonous on category axis, and the label size\n  // is close with each other. So we check the symbol size and some of the\n  // label size alone with the category axis to estimate whether all symbol\n  // can be shown without overlap.\n  var axisExtent = categoryAxis.getExtent();\n  var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis.scale.count();\n  isNaN(availSize) && (availSize = 0); // 0/0 is NaN.\n  // Sampling some points, max 5.\n\n  var dataLen = data.count();\n  var step = Math.max(1, Math.round(dataLen / 5));\n\n  for (var dataIndex = 0; dataIndex < dataLen; dataIndex += step) {\n    if (SymbolClz.getSymbolSize(data, dataIndex // Only for cartesian, where `isHorizontal` exists.\n    )[categoryAxis.isHorizontal() ? 1 : 0] // Empirical number\n    * 1.5 > availSize) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar _default = ChartView.extend({\n  type: 'line',\n  init: function () {\n    var lineGroup = new graphic.Group();\n    var symbolDraw = new SymbolDraw();\n    this.group.add(symbolDraw.group);\n    this._symbolDraw = symbolDraw;\n    this._lineGroup = lineGroup;\n  },\n  render: function (seriesModel, ecModel, api) {\n    var coordSys = seriesModel.coordinateSystem;\n    var group = this.group;\n    var data = seriesModel.getData();\n    var lineStyleModel = seriesModel.getModel('lineStyle');\n    var areaStyleModel = seriesModel.getModel('areaStyle');\n    var points = data.mapArray(data.getItemLayout);\n    var isCoordSysPolar = coordSys.type === 'polar';\n    var prevCoordSys = this._coordSys;\n    var symbolDraw = this._symbolDraw;\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var lineGroup = this._lineGroup;\n    var hasAnimation = seriesModel.get('animation');\n    var isAreaChart = !areaStyleModel.isEmpty();\n    var valueOrigin = areaStyleModel.get('origin');\n    var dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);\n    var stackedOnPoints = getStackedOnPoints(coordSys, data, dataCoordInfo);\n    var showSymbol = seriesModel.get('showSymbol');\n    var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys); // Remove temporary symbols\n\n    var oldData = this._data;\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    }); // Remove previous created symbols if showSymbol changed to false\n\n    if (!showSymbol) {\n      symbolDraw.remove();\n    }\n\n    group.add(lineGroup); // FIXME step not support polar\n\n    var step = !isCoordSysPolar && seriesModel.get('step'); // Initialization animation or coordinate system changed\n\n    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isIgnoreFunc,\n        clipShape: createClipShape(coordSys, false, true, seriesModel)\n      });\n\n      if (step) {\n        // TODO If stacked series is not step\n        points = turnPointsIntoStep(points, coordSys, step);\n        stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n      }\n\n      polyline = this._newPolyline(points, coordSys, hasAnimation);\n\n      if (isAreaChart) {\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      }\n\n      lineGroup.setClipPath(createClipShape(coordSys, true, false, seriesModel));\n    } else {\n      if (isAreaChart && !polygon) {\n        // If areaStyle is added\n        polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);\n      } else if (polygon && !isAreaChart) {\n        // If areaStyle is removed\n        lineGroup.remove(polygon);\n        polygon = this._polygon = null;\n      } // Update clipPath\n\n\n      lineGroup.setClipPath(createClipShape(coordSys, false, false, seriesModel)); // Always update, or it is wrong in the case turning on legend\n      // because points are not changed\n\n      showSymbol && symbolDraw.updateData(data, {\n        isIgnore: isIgnoreFunc,\n        clipShape: createClipShape(coordSys, false, true, seriesModel)\n      }); // Stop symbol animation and sync with line points\n      // FIXME performance?\n\n      data.eachItemGraphicEl(function (el) {\n        el.stopAnimation(true);\n      }); // In the case data zoom triggerred refreshing frequently\n      // Data may not change if line has a category axis. So it should animate nothing\n\n      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {\n        if (hasAnimation) {\n          this._updateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);\n        } else {\n          // Not do it in update with animation\n          if (step) {\n            // TODO If stacked series is not step\n            points = turnPointsIntoStep(points, coordSys, step);\n            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n          }\n\n          polyline.setShape({\n            points: points\n          });\n          polygon && polygon.setShape({\n            points: points,\n            stackedOnPoints: stackedOnPoints\n          });\n        }\n      }\n    }\n\n    var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n    polyline.useStyle(zrUtil.defaults( // Use color in lineStyle first\n    lineStyleModel.getLineStyle(), {\n      fill: 'none',\n      stroke: visualColor,\n      lineJoin: 'bevel'\n    }));\n    var smooth = seriesModel.get('smooth');\n    smooth = getSmooth(seriesModel.get('smooth'));\n    polyline.setShape({\n      smooth: smooth,\n      smoothMonotone: seriesModel.get('smoothMonotone'),\n      connectNulls: seriesModel.get('connectNulls')\n    });\n\n    if (polygon) {\n      var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');\n      var stackedOnSmooth = 0;\n      polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {\n        fill: visualColor,\n        opacity: 0.7,\n        lineJoin: 'bevel'\n      }));\n\n      if (stackedOnSeries) {\n        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n      }\n\n      polygon.setShape({\n        smooth: smooth,\n        stackedOnSmooth: stackedOnSmooth,\n        smoothMonotone: seriesModel.get('smoothMonotone'),\n        connectNulls: seriesModel.get('connectNulls')\n      });\n    }\n\n    this._data = data; // Save the coordinate system for transition animation when data changed\n\n    this._coordSys = coordSys;\n    this._stackedOnPoints = stackedOnPoints;\n    this._points = points;\n    this._step = step;\n    this._valueOrigin = valueOrigin;\n  },\n  dispose: function () {},\n  highlight: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (!symbol) {\n        // Create a temporary symbol if it is not exists\n        var pt = data.getItemLayout(dataIndex);\n\n        if (!pt) {\n          // Null data\n          return;\n        }\n\n        symbol = new SymbolClz(data, dataIndex);\n        symbol.position = pt;\n        symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));\n        symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n        symbol.__temp = true;\n        data.setItemGraphicEl(dataIndex, symbol); // Stop scale animation\n\n        symbol.stopSymbolAnimation(true);\n        this.group.add(symbol);\n      }\n\n      symbol.highlight();\n    } else {\n      // Highlight whole series\n      ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n  downplay: function (seriesModel, ecModel, api, payload) {\n    var data = seriesModel.getData();\n    var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n    if (dataIndex != null && dataIndex >= 0) {\n      var symbol = data.getItemGraphicEl(dataIndex);\n\n      if (symbol) {\n        if (symbol.__temp) {\n          data.setItemGraphicEl(dataIndex, null);\n          this.group.remove(symbol);\n        } else {\n          symbol.downplay();\n        }\n      }\n    } else {\n      // FIXME\n      // can not downplay completely.\n      // Downplay whole series\n      ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);\n    }\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolyline: function (points) {\n    var polyline = this._polyline; // Remove previous created polyline\n\n    if (polyline) {\n      this._lineGroup.remove(polyline);\n    }\n\n    polyline = new Polyline({\n      shape: {\n        points: points\n      },\n      silent: true,\n      z2: 10\n    });\n\n    this._lineGroup.add(polyline);\n\n    this._polyline = polyline;\n    return polyline;\n  },\n\n  /**\n   * @param {module:zrender/container/Group} group\n   * @param {Array.<Array.<number>>} stackedOnPoints\n   * @param {Array.<Array.<number>>} points\n   * @private\n   */\n  _newPolygon: function (points, stackedOnPoints) {\n    var polygon = this._polygon; // Remove previous created polygon\n\n    if (polygon) {\n      this._lineGroup.remove(polygon);\n    }\n\n    polygon = new Polygon({\n      shape: {\n        points: points,\n        stackedOnPoints: stackedOnPoints\n      },\n      silent: true\n    });\n\n    this._lineGroup.add(polygon);\n\n    this._polygon = polygon;\n    return polygon;\n  },\n\n  /**\n   * @private\n   */\n  // FIXME Two value axis\n  _updateAnimation: function (data, stackedOnPoints, coordSys, api, step, valueOrigin) {\n    var polyline = this._polyline;\n    var polygon = this._polygon;\n    var seriesModel = data.hostModel;\n    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);\n    var current = diff.current;\n    var stackedOnCurrent = diff.stackedOnCurrent;\n    var next = diff.next;\n    var stackedOnNext = diff.stackedOnNext;\n\n    if (step) {\n      // TODO If stacked series is not step\n      current = turnPointsIntoStep(diff.current, coordSys, step);\n      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n      next = turnPointsIntoStep(diff.next, coordSys, step);\n      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n    } // `diff.current` is subset of `current` (which should be ensured by\n    // turnPointsIntoStep), so points in `__points` can be updated when\n    // points in `current` are update during animation.\n\n\n    polyline.shape.__points = diff.current;\n    polyline.shape.points = current;\n    graphic.updateProps(polyline, {\n      shape: {\n        points: next\n      }\n    }, seriesModel);\n\n    if (polygon) {\n      polygon.setShape({\n        points: current,\n        stackedOnPoints: stackedOnCurrent\n      });\n      graphic.updateProps(polygon, {\n        shape: {\n          points: next,\n          stackedOnPoints: stackedOnNext\n        }\n      }, seriesModel);\n    }\n\n    var updatedDataInfo = [];\n    var diffStatus = diff.status;\n\n    for (var i = 0; i < diffStatus.length; i++) {\n      var cmd = diffStatus[i].cmd;\n\n      if (cmd === '=') {\n        var el = data.getItemGraphicEl(diffStatus[i].idx1);\n\n        if (el) {\n          updatedDataInfo.push({\n            el: el,\n            ptIdx: i // Index of points\n\n          });\n        }\n      }\n    }\n\n    if (polyline.animators && polyline.animators.length) {\n      polyline.animators[0].during(function () {\n        for (var i = 0; i < updatedDataInfo.length; i++) {\n          var el = updatedDataInfo[i].el;\n          el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n        }\n      });\n    }\n  },\n  remove: function (ecModel) {\n    var group = this.group;\n    var oldData = this._data;\n\n    this._lineGroup.removeAll();\n\n    this._symbolDraw.remove(true); // Remove temporary created elements when highlighting\n\n\n    oldData && oldData.eachItemGraphicEl(function (el, idx) {\n      if (el.__temp) {\n        group.remove(el);\n        oldData.setItemGraphicEl(idx, null);\n      }\n    });\n    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;\n  }\n});\n\nmodule.exports = _default;","var echarts = require(\"../echarts\");\n\nrequire(\"./line/LineSeries\");\n\nrequire(\"./line/LineView\");\n\nvar visualSymbol = require(\"../visual/symbol\");\n\nvar layoutPoints = require(\"../layout/points\");\n\nvar dataSample = require(\"../processor/dataSample\");\n\nrequire(\"../component/gridSimple\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// In case developer forget to include grid component\necharts.registerVisual(visualSymbol('line', 'circle', 'line'));\necharts.registerLayout(layoutPoints('line')); // Down sample after filter\n\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, dataSample('line'));","var _util = require(\"zrender/lib/core/util\");\n\nvar map = _util.map;\n\nvar createRenderPlanner = require(\"../chart/helper/createRenderPlanner\");\n\nvar _dataStackHelper = require(\"../data/helper/dataStackHelper\");\n\nvar isDimensionStacked = _dataStackHelper.isDimensionStacked;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(seriesType) {\n  return {\n    seriesType: seriesType,\n    plan: createRenderPlanner(),\n    reset: function (seriesModel) {\n      var data = seriesModel.getData();\n      var coordSys = seriesModel.coordinateSystem;\n      var pipelineContext = seriesModel.pipelineContext;\n      var isLargeRender = pipelineContext.large;\n\n      if (!coordSys) {\n        return;\n      }\n\n      var dims = map(coordSys.dimensions, function (dim) {\n        return data.mapDimension(dim);\n      }).slice(0, 2);\n      var dimLen = dims.length;\n      var stackResultDim = data.getCalculationInfo('stackResultDimension');\n\n      if (isDimensionStacked(data, dims[0]\n      /*, dims[1]*/\n      )) {\n        dims[0] = stackResultDim;\n      }\n\n      if (isDimensionStacked(data, dims[1]\n      /*, dims[0]*/\n      )) {\n        dims[1] = stackResultDim;\n      }\n\n      function progress(params, data) {\n        var segCount = params.end - params.start;\n        var points = isLargeRender && new Float32Array(segCount * dimLen);\n\n        for (var i = params.start, offset = 0, tmpIn = [], tmpOut = []; i < params.end; i++) {\n          var point;\n\n          if (dimLen === 1) {\n            var x = data.get(dims[0], i);\n            point = !isNaN(x) && coordSys.dataToPoint(x, null, tmpOut);\n          } else {\n            var x = tmpIn[0] = data.get(dims[0], i);\n            var y = tmpIn[1] = data.get(dims[1], i); // Also {Array.<number>}, not undefined to avoid if...else... statement\n\n            point = !isNaN(x) && !isNaN(y) && coordSys.dataToPoint(tmpIn, null, tmpOut);\n          }\n\n          if (isLargeRender) {\n            points[offset++] = point ? point[0] : NaN;\n            points[offset++] = point ? point[1] : NaN;\n          } else {\n            data.setItemLayout(i, point && point.slice() || [NaN, NaN]);\n          }\n        }\n\n        isLargeRender && data.setLayout('symbolPoints', points);\n      }\n\n      return dimLen && {\n        progress: progress\n      };\n    }\n  };\n}\n\nmodule.exports = _default;","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar graphic = require(\"../../util/graphic\");\n\nvar _number = require(\"../../util/number\");\n\nvar parsePercent = _number.parsePercent;\n\nvar _labelHelper = require(\"./labelHelper\");\n\nvar getDefaultLabel = _labelHelper.getDefaultLabel;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @module echarts/chart/helper/Symbol\n */\n\n/**\n * @constructor\n * @alias {module:echarts/chart/helper/Symbol}\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @extends {module:zrender/graphic/Group}\n */\nfunction SymbolClz(data, idx, seriesScope) {\n  graphic.Group.call(this);\n  this.updateData(data, idx, seriesScope);\n}\n\nvar symbolProto = SymbolClz.prototype;\n/**\n * @public\n * @static\n * @param {module:echarts/data/List} data\n * @param {number} dataIndex\n * @return {Array.<number>} [width, height]\n */\n\nvar getSymbolSize = SymbolClz.getSymbolSize = function (data, idx) {\n  var symbolSize = data.getItemVisual(idx, 'symbolSize');\n  return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];\n};\n\nfunction getScale(symbolSize) {\n  return [symbolSize[0] / 2, symbolSize[1] / 2];\n}\n\nfunction driftSymbol(dx, dy) {\n  this.parent.drift(dx, dy);\n}\n\nsymbolProto._createSymbol = function (symbolType, data, idx, symbolSize, keepAspect) {\n  // Remove paths created before\n  this.removeAll();\n  var color = data.getItemVisual(idx, 'color'); // var symbolPath = createSymbol(\n  //     symbolType, -0.5, -0.5, 1, 1, color\n  // );\n  // If width/height are set too small (e.g., set to 1) on ios10\n  // and macOS Sierra, a circle stroke become a rect, no matter what\n  // the scale is set. So we set width/height as 2. See #4150.\n\n  var symbolPath = createSymbol(symbolType, -1, -1, 2, 2, color, keepAspect);\n  symbolPath.attr({\n    z2: 100,\n    culling: true,\n    scale: getScale(symbolSize)\n  }); // Rewrite drift method\n\n  symbolPath.drift = driftSymbol;\n  this._symbolType = symbolType;\n  this.add(symbolPath);\n};\n/**\n * Stop animation\n * @param {boolean} toLastFrame\n */\n\n\nsymbolProto.stopSymbolAnimation = function (toLastFrame) {\n  this.childAt(0).stopAnimation(toLastFrame);\n};\n/**\n * FIXME:\n * Caution: This method breaks the encapsulation of this module,\n * but it indeed brings convenience. So do not use the method\n * unless you detailedly know all the implements of `Symbol`,\n * especially animation.\n *\n * Get symbol path element.\n */\n\n\nsymbolProto.getSymbolPath = function () {\n  return this.childAt(0);\n};\n/**\n * Get scale(aka, current symbol size).\n * Including the change caused by animation\n */\n\n\nsymbolProto.getScale = function () {\n  return this.childAt(0).scale;\n};\n/**\n * Highlight symbol\n */\n\n\nsymbolProto.highlight = function () {\n  this.childAt(0).trigger('emphasis');\n};\n/**\n * Downplay symbol\n */\n\n\nsymbolProto.downplay = function () {\n  this.childAt(0).trigger('normal');\n};\n/**\n * @param {number} zlevel\n * @param {number} z\n */\n\n\nsymbolProto.setZ = function (zlevel, z) {\n  var symbolPath = this.childAt(0);\n  symbolPath.zlevel = zlevel;\n  symbolPath.z = z;\n};\n\nsymbolProto.setDraggable = function (draggable) {\n  var symbolPath = this.childAt(0);\n  symbolPath.draggable = draggable;\n  symbolPath.cursor = draggable ? 'move' : 'pointer';\n};\n/**\n * Update symbol properties\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Object} [seriesScope]\n * @param {Object} [seriesScope.itemStyle]\n * @param {Object} [seriesScope.hoverItemStyle]\n * @param {Object} [seriesScope.symbolRotate]\n * @param {Object} [seriesScope.symbolOffset]\n * @param {module:echarts/model/Model} [seriesScope.labelModel]\n * @param {module:echarts/model/Model} [seriesScope.hoverLabelModel]\n * @param {boolean} [seriesScope.hoverAnimation]\n * @param {Object} [seriesScope.cursorStyle]\n * @param {module:echarts/model/Model} [seriesScope.itemModel]\n * @param {string} [seriesScope.symbolInnerColor]\n * @param {Object} [seriesScope.fadeIn=false]\n */\n\n\nsymbolProto.updateData = function (data, idx, seriesScope) {\n  this.silent = false;\n  var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n  var seriesModel = data.hostModel;\n  var symbolSize = getSymbolSize(data, idx);\n  var isInit = symbolType !== this._symbolType;\n\n  if (isInit) {\n    var keepAspect = data.getItemVisual(idx, 'symbolKeepAspect');\n\n    this._createSymbol(symbolType, data, idx, symbolSize, keepAspect);\n  } else {\n    var symbolPath = this.childAt(0);\n    symbolPath.silent = false;\n    graphic.updateProps(symbolPath, {\n      scale: getScale(symbolSize)\n    }, seriesModel, idx);\n  }\n\n  this._updateCommon(data, idx, symbolSize, seriesScope);\n\n  if (isInit) {\n    var symbolPath = this.childAt(0);\n    var fadeIn = seriesScope && seriesScope.fadeIn;\n    var target = {\n      scale: symbolPath.scale.slice()\n    };\n    fadeIn && (target.style = {\n      opacity: symbolPath.style.opacity\n    });\n    symbolPath.scale = [0, 0];\n    fadeIn && (symbolPath.style.opacity = 0);\n    graphic.initProps(symbolPath, target, seriesModel, idx);\n  }\n\n  this._seriesModel = seriesModel;\n}; // Update common properties\n\n\nvar normalStyleAccessPath = ['itemStyle'];\nvar emphasisStyleAccessPath = ['emphasis', 'itemStyle'];\nvar normalLabelAccessPath = ['label'];\nvar emphasisLabelAccessPath = ['emphasis', 'label'];\n/**\n * @param {module:echarts/data/List} data\n * @param {number} idx\n * @param {Array.<number>} symbolSize\n * @param {Object} [seriesScope]\n */\n\nsymbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n  var symbolPath = this.childAt(0);\n  var seriesModel = data.hostModel;\n  var color = data.getItemVisual(idx, 'color'); // Reset style\n\n  if (symbolPath.type !== 'image') {\n    symbolPath.useStyle({\n      strokeNoScale: true\n    });\n  }\n\n  var itemStyle = seriesScope && seriesScope.itemStyle;\n  var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n  var symbolRotate = seriesScope && seriesScope.symbolRotate;\n  var symbolOffset = seriesScope && seriesScope.symbolOffset;\n  var labelModel = seriesScope && seriesScope.labelModel;\n  var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n  var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n  var cursorStyle = seriesScope && seriesScope.cursorStyle;\n\n  if (!seriesScope || data.hasItemOption) {\n    var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx); // Color must be excluded.\n    // Because symbol provide setColor individually to set fill and stroke\n\n    itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n    hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n    symbolRotate = itemModel.getShallow('symbolRotate');\n    symbolOffset = itemModel.getShallow('symbolOffset');\n    labelModel = itemModel.getModel(normalLabelAccessPath);\n    hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n    hoverAnimation = itemModel.getShallow('hoverAnimation');\n    cursorStyle = itemModel.getShallow('cursor');\n  } else {\n    hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n  }\n\n  var elStyle = symbolPath.style;\n  symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n  if (symbolOffset) {\n    symbolPath.attr('position', [parsePercent(symbolOffset[0], symbolSize[0]), parsePercent(symbolOffset[1], symbolSize[1])]);\n  }\n\n  cursorStyle && symbolPath.attr('cursor', cursorStyle); // PENDING setColor before setStyle!!!\n\n  symbolPath.setColor(color, seriesScope && seriesScope.symbolInnerColor);\n  symbolPath.setStyle(itemStyle);\n  var opacity = data.getItemVisual(idx, 'opacity');\n\n  if (opacity != null) {\n    elStyle.opacity = opacity;\n  }\n\n  var liftZ = data.getItemVisual(idx, 'liftZ');\n  var z2Origin = symbolPath.__z2Origin;\n\n  if (liftZ != null) {\n    if (z2Origin == null) {\n      symbolPath.__z2Origin = symbolPath.z2;\n      symbolPath.z2 += liftZ;\n    }\n  } else if (z2Origin != null) {\n    symbolPath.z2 = z2Origin;\n    symbolPath.__z2Origin = null;\n  }\n\n  var useNameLabel = seriesScope && seriesScope.useNameLabel;\n  graphic.setLabelStyle(elStyle, hoverItemStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: idx,\n    defaultText: getLabelDefaultText,\n    isRectText: true,\n    autoColor: color\n  }); // Do not execute util needed.\n\n  function getLabelDefaultText(idx, opt) {\n    return useNameLabel ? data.getName(idx) : getDefaultLabel(data, idx);\n  }\n\n  symbolPath.off('mouseover').off('mouseout').off('emphasis').off('normal');\n  symbolPath.hoverStyle = hoverItemStyle; // FIXME\n  // Do not use symbol.trigger('emphasis'), but use symbol.highlight() instead.\n\n  graphic.setHoverStyle(symbolPath);\n  var scale = getScale(symbolSize);\n\n  if (hoverAnimation && seriesModel.isAnimationEnabled()) {\n    var onEmphasis = function () {\n      // Do not support this hover animation util some scenario required.\n      // Animation can only be supported in hover layer when using `el.incremetal`.\n      if (this.incremental) {\n        return;\n      }\n\n      var ratio = scale[1] / scale[0];\n      this.animateTo({\n        scale: [Math.max(scale[0] * 1.1, scale[0] + 3), Math.max(scale[1] * 1.1, scale[1] + 3 * ratio)]\n      }, 400, 'elasticOut');\n    };\n\n    var onNormal = function () {\n      if (this.incremental) {\n        return;\n      }\n\n      this.animateTo({\n        scale: scale\n      }, 400, 'elasticOut');\n    };\n\n    symbolPath.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);\n  }\n};\n/**\n * @param {Function} cb\n * @param {Object} [opt]\n * @param {Object} [opt.keepLabel=true]\n */\n\n\nsymbolProto.fadeOut = function (cb, opt) {\n  var symbolPath = this.childAt(0); // Avoid mistaken hover when fading out\n\n  this.silent = symbolPath.silent = true; // Not show text when animating\n\n  !(opt && opt.keepLabel) && (symbolPath.style.text = null);\n  graphic.updateProps(symbolPath, {\n    style: {\n      opacity: 0\n    },\n    scale: [0, 0]\n  }, this._seriesModel, this.dataIndex, cb);\n};\n\nzrUtil.inherits(SymbolClz, graphic.Group);\nvar _default = SymbolClz;\nmodule.exports = _default;"],"sourceRoot":""}